/*
 *    Date: 2018 10 24
 * Project: Nodas - EntityManager
 *
 * Copyright 2018 SIT srl
 */

var entTemp = require("./grafoLogger").grafoLogger;
var async = require("async");
var util = require("util");
var self = {};

// macro to manage check of presence of valid civici on arco to delete
var _ARCO_WITH_VALID_CIVICI = "ARCO_WITH_VALID_CIVICI";

var arco = function()
{
  arco.super_.call(this);

  this.moduleName = "Entity arco";
  this.entityName = "arco";
  this.schemaName = "grafo";
  this.tableName = "arco";
  this.tableSrid  = 32633;

  this.fieldTypeObj = {
    data_ini: this.crudUtils.TIMESTAMP,
    data_imm: this.crudUtils.TIMESTAMP,
    data_fine: this.crudUtils.TIMESTAMP,
    data_ult_man: this.crudUtils.TIMESTAMP,
    data_ri_mappa: this.crudUtils.TIMESTAMP,
    data_pros_int: this.crudUtils.TIMESTAMP
  };

  this.masterFieldObj = [
    {name: "data_fine"},
    {name: "cod_arco"},
    {name: "cod_via"},
    {name: "nodo_da"},
    {name: "nodo_a"},
    {name: "geom", aliasF:"x_min", operator:this.crudUtils.X_MIN},
    {name: "geom", aliasF:"x_max", operator:this.crudUtils.X_MAX},
    {name: "geom", aliasF:"y_min", operator:this.crudUtils.Y_MIN},
    {name: "geom", aliasF:"y_max", operator:this.crudUtils.Y_MAX}
  ];
  this.detailFieldObj = [
    {name: "cod_arco"},
    {name: "cod_via"},
    {name: "nome_via"},
    {name: "nodo_da"},
    {name: "nodo_a"},
    {name: "cod_via_da"},
    {name: "cod_via_a"},
    {name: "prog_x_via"},
    {name: "mt_da"},
    {name: "mt_a"},
    {name: "data_ini"},
    {name: "data_fine"},
    {name: "lunghezza"},
    {name: "larghezza"},
    {name: "superficie"},
    {name: "corsie"},
    {name: "civiminp"},
    {name: "espominp"},
    {name: "civimaxp"},
    {name: "espomaxp"},
    {name: "civimind"},
    {name: "espomind"},
    {name: "civimaxd"},
    {name: "espomaxd"},
    {name: "estr_verif"},
    {name: "cresciv"},
    {name: "id_muni_pari"},
    {name: "id_muni_disp"},
    {name: "id_quart_pari"},
    {name: "id_quart_disp"},
    {name: "id_uso"},
    {name: "id_classe"},
    {name: "id_tipo"},
    {name: "id_sede"},
    {name: "id_livello"},
    {name: "id_paviment"},
    {name: "id_portata"},
    {name: "id_stato_cons"},
    {name: "id_sezione"},
    {name: "id_tipologia"},
    {name: "id_funzionalita"},
    {name: "id_tipo_lim_amm"},
    {name: "id_class_funz"},
    {name: "id_fondo"},
    {name: "id_carreggiata"},
    {name: "id_marcia"},
    {name: "id_stato_esercizio"},
    {name: "id_origine"},
    {name: "id_fonte"},
    {name: "data_imm"},
    {name: "data_ri_mappa"},
    {name: "data_pros_int"},
    {name: "id_delib_denom"},
    {name: "id_delib_propr"},
    {name: "determ_valore"},
    {name: "senso_perc"},
    {name: "id_viabilita"},
    {name: "id_fondazione"},
    {name: "id_corpi_illum"},
    {name: "id_stra_cs"},
    {name: "id_proprieta"},
    {name: "id_senso_percorrenza"},
    {name: "prev_arco"},
    {name: "prev_arco_suppl"},
    {name: "geom", aliasF:"x_min", operator:this.crudUtils.X_MIN},
    {name: "geom", aliasF:"x_max", operator:this.crudUtils.X_MAX},
    {name: "geom", aliasF:"y_min", operator:this.crudUtils.Y_MIN},
    {name: "geom", aliasF:"y_max", operator:this.crudUtils.Y_MAX}
    /* UNUSED
    {name: "testo"},
    {name: "ora_vari"},
    {name: "localita"},
    {name: "data_ult_man"},
    {name: "zigzag"},
    {name: "acqued"},
    {name: "gasdot"},
    {name: "telefoni"},
    {name: "elettr"},
    {name: "fogne_bianche"},
    {name: "fogne_nere"},
    {name: "scolina"},
    {name: "operedarte"},
    {name: "guardrail"},
    {name: "centro_edif"},
    {name: "segnaletica_vert"},
    {name: "segnaletica_oriz"},
    {name: "pista_cicl"},
    {name: "marciapiede"},
    {name: "id_fondaz_1"},
    {name: "prof_fondaz_1"},
    {name: "id_fondaz_2"},
    {name: "prof_fondaz_2"},
    {name: "id_fondaz_3"},
    {name: "prof_fondaz_3"},
    {name: "id_fondaz_4"},
    {name: "prof_fondaz_4"},
    */
  ];

  this.entityId = "cod_arco";
  this.entityIdType = this.crudUtils.INTEGER;

  /*
   * Variables to manage the log into grafo.civico_trac table of civici on arco
   */

  // array of id that could assume id_mot_ridenominazione
  // that must be skipped on logging operation
  // (reference to tables grafo.arco_mot_ridenominazione)
  this.idMotRidenominazioneToSkip  = [3];
}

/*
 * Inheritance
 */
util.inherits(arco,entTemp);

arco.prototype.init = function(opt)
{
  self = this;
  arco.super_.prototype.init.call(self,opt);
}

arco.prototype.detail = function(opt,callback)
{
  opt.tableName = "view_arco";

  arco.super_.prototype.detail.call(self,opt,callback);
}

arco.prototype.update = function(opt,callback)
{
  opt.tableName = "arco";

  if (!opt.object.arcoPoints)
    arco.super_.prototype.update.call(self,opt,callback);
  else
  {
    /*
     * We have also to reproject civico related on this arco
     * (execute these operations in transaction)
     *
     * build geometry to update from received points as:
     *
     * ST_SetSRID(ST_MakeLine(ARRAY[ST_MakePoint(x1,y1), ST_MakePoint(x2,y2), ... ]),<srid>)
     *
     */

    var qString = "UPDATE grafo.arco AS NEW SET ";
    var qRet    = "RETURNING ";

    // cycle on attributes to build dinamically attrs and values list
    Object.keys(opt.object).forEach(function(key)
    {
      switch(key)
      {
        case 'arcoPoints':
          var arcoGeom =
            "ST_SetSRID(" +
              "ST_MakeLine(ARRAY[";

          for (var idx=0; idx<opt.object.arcoPoints.length; idx++)
          {
            arcoGeom += "ST_MakePoint(" + opt.object.arcoPoints[idx][0] + ", " +
                                          opt.object.arcoPoints[idx][1] + ")";

            if (idx < opt.object.arcoPoints.length -1)
              arcoGeom += ", ";
          }

          arcoGeom += "]), " + self.tableSrid + ")";

          qString += "geom = ";
          qString += arcoGeom + ", ";
          break;

        default:
          qString += key + " = ";
          qString += opt.object[key] + ", ";
          qRet    += "OLD." + key + ", ";
      }
    });

    // remove last comma
    qString = qString.substring(0, qString.lastIndexOf(","));
    qRet    = qRet.substring(0, qRet.lastIndexOf(","));

    qString += " FROM grafo.arco AS OLD ";

    // add where condition
    qString += "WHERE OLD.cod_arco = $1 AND OLD.cod_arco = NEW.cod_arco ";

    // add returning option
    qString += qRet;


    var now = new Date().getTime();

    var transName = "reshape_arco_" + now;


    // Begin transaction
    self.crud.beginTransaction(transName, function(btErr)
    {
      if (btErr)
      {
        callback(btErr,null);
        return;
      }

      var qOpt = {
        queryString: qString,
        transName: transName
      };

      self.crud.update(qOpt, [{value:opt.id}], function(err,res)
      {
        if (err || !res.result)
        {
          var msg = "Error on update arco " + opt.id + (err ? ": " + err.message : "");

          self.log.error(self.moduleName + " - " + msg);

          self.crud.rollbackTransaction(transName,function(e)
          {
            callback({message:msg},null);
          });
        }
        else
        {
          /*
           * Reproject all valid civico related to this arco
           * Query to execute to retrieve civico related to this arco:
           *
           * SELECT id,x,y
           * FROM grafo.view_civico
           * WHERE cod_arco = <cod_arco>
           *   AND is_valid_now = true
           *
           */

          var qOpt = {
            transName: transName,
            fields: [
              {name: "id"},{name: "x"},{name: "y"}
            ],
            from: [
              {schema:"grafo", name:"view_civico", type:self.crudUtils.TABLE}
            ],
            where:[
              {
                typeCond: self.crudUtils.SIMPLE_COND,
                leftSide: "cod_arco",
                operator: self.crudUtils.EQ,
                rightSide: "$1",
                nextCond: self.crudUtils.AND
              },
              {
                typeCond: self.crudUtils.SIMPLE_COND,
                leftSide: "is_valid_now",
                operator: self.crudUtils.EQ,
                rightSide: true
              }
            ]
          };

          self.crud.select(qOpt, [{value:opt.id}], function(errS,resS)
          {
            if (errS)
            {
              self.log.error(self.moduleName + " - Error on find civici for arco "
                + opt.id + ": " + err.message);

             self.crud.rollbackTransaction(transName,function(e)
              {
                callback(errS,null);
              });
            }
            else
            {
              var tasks = {};
              var civicoEnt = self.entityHolder.getEntity("civico");

              for (var idx=0; idx<resS.result.length; idx++)
              {
                var civicoData = resS.result[idx];

                createReprojectCivicoTask(idx, civicoData, opt.id, tasks, civicoEnt, transName);
              }

              // execute tasks to reproject civici on reshaped arco
              async.parallelLimit(tasks, 1, function(errT,resT)
              {
                if (errT)
                {
                  // manage tasks error
                  self.log.error(self.moduleName + " - Error: " + errT.message);

                  self.crud.rollbackTransaction(transName,function(e)
                  {
                    callback(errT,null);
                  });
                }
                else
                {
                  self.crud.commitTransaction(transName, function(e)
                  {
                    callback(e,e ? null : res);
                  });

                  // write into log table
                  var change = [];

                  // cycle on changed object to log their old and new values (not for arcoPoints)
                  Object.keys(opt.object).forEach(function(key)
                  {
                    if (res.result[0] && key != 'arcoPoints')
                    {
                      change.push({
                        key:key,
                        new:opt.object[key],
                        old:res.result[0][key]
                      });
                    }
                  });

                  var logOpt = {
                    object: [{
                      user_id: opt.sysuser_id,
                      entity: "arco",
                      entity_id: opt.id,
                      operation: "Sagomatura arco",
                      change: change
                    }]
                  };

                  self.entityHolder.getEntity("grafoLog").bulkInsert(
                    logOpt,
                    function(lErr,lRes){}
                  );

                }
              });
            }
          });
        }
      });
    });
  }
}

/*
 * New methods
 */

// Retrieve all via of arco (not ceased) that begin or end in given node
arco.prototype.streetForNode = function(opt,callback)
{
  var nd = opt.object.nodo_da;
  var na = opt.object.nodo_a;

  // if arco is valued, we have to remove this cod_arco from query
  // (otherwise we show into result also via of current arco)
  var arco = opt.object.arco;

  if (!nd && !na)
  {
    callback({message:"Missing nodo_da/nodo_a parameters"},null);
    return;
  }

  /* Prepare query */
  var retObj = {result:{}};
  var aQuery = [];

  if (nd)
  {
    var obj = {key:"nodo_da", nodo:nd};
    if (arco)
      obj['arco'] = arco;

    aQuery.push(obj);
  }

  if (na)
  {
    var obj = {key:"nodo_a", nodo:na};
    if (arco)
      obj['arco'] = arco;

    aQuery.push(obj);
  }


  /* Exec query */
  async.eachLimit(aQuery,1,function(obj,cb)
  {
    var qs = "SELECT DISTINCT v.cod_via,v.denominazione FROM grafo.arco a " +
      "LEFT JOIN grafo.via v ON a.cod_via = v.cod_via " +
      "WHERE (a.nodo_a = $1 OR a.nodo_da = $1) AND a.data_fine IS NULL";

    var value = [{value:obj.nodo}];

    // check if add given arco condition
    if(obj.arco)
    {
      qs += " AND a.cod_arco != $2";
      value.push({value:obj.arco});
    }

    self.crud.select({queryString:qs},value,function(err,res)
    {
      if (res && res.result)
        retObj.result[obj.key] = res.result;

      cb(err);
    });
  },
  function(err)
  {
    callback(err,err ? null : retObj);
  });
}

// Retrieve via of given arco (not ceased)
arco.prototype.streetForArco = function(opt,callback)
{
  var arcoFrom = opt.object.arco_da;
  var arcoTo = opt.object.arco_a;

  if (!arcoFrom && !arcoTo)
  {
    callback({message:"Missing arco_da/arco_a parameters"},null);
    return;
  }

  /* Prepare query */
  var retObj = {result:{}};
  var aQuery = [];

  if (arcoFrom) aQuery.push({key:"arco_da",val:arcoFrom});
  if (arcoTo) aQuery.push({key:"arco_a", val:arcoTo});

  /* Exec query */
  async.eachLimit(aQuery,1,function(obj,cb)
  {
    var qs = "SELECT v.cod_via,v.denominazione FROM grafo.arco a " +
      "LEFT JOIN grafo.via v ON a.cod_via = v.cod_via " +
      "WHERE a.cod_arco = $1 AND a.data_fine IS NULL";

    self.crud.select({queryString:qs},[{value:obj.val}],function(err,res)
    {
      if (res && res.result)
        retObj.result[obj.key] = res.result;

      cb(err);
    });
  },
  function(err)
  {
    callback(err,err ? null : retObj);
  });
}

// remove arco
arco.prototype.remove = function(opt,callback)
{
  /*
   * we have to:
   *
   * 1. check if on given arco there are valid civico (with data_fine null)
   *
   * 2. if no, delete arco (update with data_fine), if yes return error
   *
   * 3. if remain node without any arco associated, we have to remove it
   *
   */

  var transName = "remove_arco_" + new Date().getTime();

  /*
   * Query to execute
   *
   * SELECT id FROM grafo.civico
   * WHERE cod_arco = <cod_arco>
   * AND data_fine IS NULL
   *
   */

  var qOpt = {
    transName: transName,
    fields:[
      {name:'id'}
    ],
    from:[
      {schema:'grafo', name:'civico', type:self.crudUtils.TABLE}
    ],
    where:[
      {
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: 'cod_arco',
        operator: self.crudUtils.EQ,
        rightSide: '$1',
        nextCond: self.crudUtils.AND
      },
      {
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: 'data_fine',
        operator: self.crudUtils.IS,
        rightSide: null
      }
    ]
  };

  // Begin transaction
  self.crud.beginTransaction(transName, function(btErr)
  {
    if (btErr)
    {
      callback(btErr,null);
      return;
    }

    // check if given arco has valid civici on it
    self.crud.select(qOpt, [{value:opt.id}], function(errC, resC)
    {
      if (errC)
      {
        var msg = "Error on retrieve valid civici on arco " + opt.id;

        self.log.error(self.moduleName + " - " + msg + ": " +errC.message);

        self.crud.rollbackTransaction(transName, function(rollErr)
        {
          callback({message:msg}, null);
        });

        //return callback({message:msg}, null);
      }
      else if (resC && resC.result.length > 0)
      {
        self.log.info(self.moduleName + " - arco " + opt.id +
          " has valid civici on it. It cannot be removed!");

        self.crud.rollbackTransaction(transName, function(rollErr)
        {
          callback({message:_ARCO_WITH_VALID_CIVICI}, null);
        });

        //return callback({message:_ARCO_WITH_VALID_CIVICI}, null);
      }
      else
      {
        // update arco (set data_fine)
        opt.transName = transName;
        opt.operation = "Rimozione arco";

        arco.super_.prototype.update.call(self,opt,function(errU,resU)
        {
          if (errU || !resU.result)
          {
            var msg = "Error on cessation arco with cod_arco " + opt.id;

            var logMsg = msg + (errU ? ": " + errU.message : "");

            self.log.error(self.moduleName + " - " + logMsg);

            self.crud.rollbackTransaction(transName, function(rollErr)
            {
              callback({message:msg}, null);
            });

            //callback({message:msg},null);
          }
          else
          {
            /*
             * Query to execute to check if nodes related to given arco
             * remain orphans (without other archi that flow into them):
             *
             * SELECT nodo_a,
             *        (SELECT COUNT(0)::integer
             *         FROM (
             *            SELECT cod_arco
             *            FROM grafo.arco
             *            WHERE nodo_a =
             *                (SELECT nodo_a AS nodo
             *                 FROM grafo.arco
             *                 WHERE cod_arco = $1)
             *            AND cod_arco != $1 AND data_fine IS NULL
             *            UNION
             *            SELECT cod_arco
             *            FROM grafo.arco
             *            WHERE nodo_da =
             *                (SELECT nodo_a AS nodo
             *                 FROM grafo.arco
             *                 WHERE cod_arco = $1)
             *            AND cod_arco != $1 AND data_fine IS NULL) AS t
             *          ) AS num_arco
             * FROM grafo.arco
             * WHERE cod_arco = $1
             *
             * UNION
             *
             * SELECT nodo_da,
             *        (SELECT COUNT(0)::integer
             *         FROM (
             *            SELECT cod_arco
             *            FROM grafo.arco
             *            WHERE nodo_a =
             *                (SELECT nodo_da AS nodo
             *                 FROM grafo.arco
             *                 WHERE cod_arco = $1)
             *            AND cod_arco != $1 AND data_fine IS NULL
             *            UNION
             *            SELECT cod_arco
             *            FROM grafo.arco
             *            WHERE nodo_da =
             *                (SELECT nodo_da AS nodo
             *                 FROM grafo.arco
             *                 WHERE cod_arco = $1)
             *            AND cod_arco != $1 AND data_fine IS NULL) AS t
             *          ) AS num_arco
             * FROM grafo.arco
             * WHERE cod_arco = $1
             *
             */

            var qStr =
              "SELECT nodo_a AS id, (SELECT COUNT(0)::integer FROM (" +
              "SELECT cod_arco FROM grafo.arco WHERE nodo_a = " +
              "(SELECT nodo_a AS nodo FROM grafo.arco WHERE cod_arco = $1) " +
              "AND cod_arco != $1 AND data_fine IS NULL " +
              "UNION SELECT cod_arco FROM grafo.arco WHERE nodo_da = " +
              "(SELECT nodo_a AS nodo FROM grafo.arco WHERE cod_arco = $1) " +
              "AND cod_arco != $1 AND data_fine IS NULL) AS t " +
              ") AS num_arco FROM grafo.arco WHERE cod_arco = $1 UNION " +
              "SELECT nodo_da AS id, (SELECT COUNT(0)::integer FROM ( " +
              "SELECT cod_arco FROM grafo.arco WHERE nodo_a = " +
              "(SELECT nodo_da AS nodo FROM grafo.arco " +
              "WHERE cod_arco = $1) AND cod_arco != $1 AND data_fine IS NULL " +
              "UNION SELECT cod_arco FROM grafo.arco WHERE nodo_da = " +
              "(SELECT nodo_da AS nodo FROM grafo.arco WHERE cod_arco = $1) " +
              "AND cod_arco != $1 AND data_fine IS NULL) AS t " +
              ") AS num_arco FROM grafo.arco WHERE cod_arco = $1";

            // Exec query
            var qOpt = {transName:transName,queryString:qStr};

            self.crud.select(qOpt,[{value:opt.id}],function(errS, resS)
            {
              if (errS)
              {
                self.log.error(self.moduleName + " - " + errS.message);

                self.crud.rollbackTransaction(transName, function(rollErr)
                {
                  callback(errS, null);
                });
              }
              else
              {
                // check if there are orphan nodes to remove
                var qVal = [{value:new Date(opt.object.data_fine)}];
                var qPar = [];
                var countPar = 2;

                for (var idx=0; idx<resS.result.length; idx++)
                {
                  if (resS.result[idx].num_arco == 0)
                  {
                    qPar.push("$"+countPar++);
                    qVal.push({value:resS.result[idx].id});
                  }
                }

                if (qPar.length)
                {
                  self.log.info(self.moduleName + " - There are " + qPar.length +
                    " orphan nodes to remove");
                  /*
                   * Query to execute to remove orphan nodes:
                   *
                   * UPDATE grafo.nodo
                   * SET data_fine = <data>
                   * WHERE id IN (<list_id>)
                   *
                   */

                  qOpt = {
                    transName: transName,
                    table:{schema:"grafo", name:"nodo"},
                    fields:[{name:"data_fine"}],
                    fieldType:{data_fine:self.crudUtils.TIMESTAMP},
                    where:[
                      {
                        typeCond: self.crudUtils.SIMPLE_COND,
                        leftSide: "id",
                        operator: self.crudUtils.IN,
                        rightSide: qPar.join(),
                      }
                    ]
                  };

                  self.crud.update(qOpt, qVal, function(errUN, resUN)
                  {
                    if (errUN)
                    {
                      self.log.error(self.moduleName + " - " + errUN.message);

                      self.crud.rollbackTransaction(transName, function(rollErr)
                      {
                        callback(errUN, null);
                      });
                    }
                    else
                    {
                      self.crud.commitTransaction(transName,function(commErr)
                      {
                        callback(commErr,commErr ? null : resU);
                      });

                      // write into log
                      // this for begin from 1 because
                      // first value into qVal array is data_fine
                      for (var idx=1; idx<qVal.length; idx++)
                      {
                        var change = [{
                          key:"data_fine",
                          new:new Date(opt.object.data_fine)
                        }];

                        var logOpt = {
                          object: [{
                            user_id: opt.sysuser_id,
                            entity: "nodo",
                            entity_id: qVal[idx].value,
                            operation: "Rimozione arco",
                            change: change
                          }]
                        };

                        self.entityHolder.getEntity("grafoLog").bulkInsert(
                          logOpt,
                          function(lErr,lRes){}
                        );
                      }

                    }
                  });
                }
                else
                {
                  self.log.info(self.moduleName + " - There aren't orphan nodes to remove");

                  // there aren't orphan nodes to remove -> commit
                  self.crud.commitTransaction(transName,function(commErr)
                  {
                    callback(commErr,commErr ? null : resU);
                  });
                }
              }
            });
          }
            //callback(null, resU);
        });
      }
    });


  });
}

// create new arco
arco.prototype.create = function(opt,callback)
{
  /*
   * we have to:
   *
   * 1. check if is necessary insert new nodes (and insert them)
   * 2. insert new arco
   * 3. check if is necessary break existing arco with inserted nodes
   *
   */

  var nodeTasks = {};

  var transName = "create_arco_" + new Date().getTime();

  // date is set to value in the form or to now (if missing form value)
  var date = opt.object.newArcoAttrs.data_ini ?
    new Date(opt.object.newArcoAttrs.data_ini) : new Date();

  // Begin transaction
  self.crud.beginTransaction(transName, function(btErr)
  {
    if (btErr)
    {
      callback(btErr,null);
      return;
    }

    // read data from request
    var nodeFromId = opt.object.nodeFrom.nodo;
    var nodeToId   = opt.object.nodeTo.nodo

    var arcoFromId = opt.object.nodeFrom.arco;
    var arcoToId   = opt.object.nodeTo.arco

    // build task to insert node from
    if (!nodeFromId)
    {
      /*
       * Query to execute:
       *
       * INSERT INTO grafo.nodo (data_ini, geom)
       * VALUES ($1, ST_SetSRID(ST_MakePoint($2,$3),<srid>))
       * RETURNING id
       *
       */

      var nodo =
        "ST_SetSRID("+
          "ST_MakePoint(" + opt.object.nodeFrom.coords[0] + ", " +
                            opt.object.nodeFrom.coords[1] + "), " +
          self.tableSrid +
        ")";

      var qString =
        "INSERT INTO grafo.nodo (data_ini, geom) " +
        //"VALUES ('" + date.toCustomString() + "', " + nodo + ") " +
        "VALUES ($1, " + nodo + ") " +
        "RETURNING id;";

      var fromOpt = {
        sysuser_id:opt.sysuser_id,
        transName: transName,
        queryString: qString
      };


      nodeTasks.nodeFrom = function(cb){self.crud.insert(fromOpt,[{value:date}],cb);};
    }

    // build task to insert node to
    if (!nodeToId)
    {
      /*
       * Query to execute:
       *
       * INSERT INTO grafo.nodo (data_ini, geom)
       * VALUES ($1, ST_SetSRID(ST_MakePoint($2,$3),<srid>))
       * RETURNING id
       *
       */

      var nodo =
        "ST_SetSRID(" +
          "ST_MakePoint(" + opt.object.nodeTo.coords[0] + ", " +
                            opt.object.nodeTo.coords[1] + "), " +
          self.tableSrid +
        ")";

      var qString =
        "INSERT INTO grafo.nodo (data_ini, geom) " +
        //"VALUES ('" + date.toCustomString() + "', " + nodo + ") " +
        "VALUES ($1, " + nodo + ") " +
        "RETURNING id;";

      var toOpt = {
        sysuser_id:opt.sysuser_id,
        transName: transName,
        queryString: qString
      };

      nodeTasks.nodeTo = function(cb){self.crud.insert(toOpt,[{value:date}],cb);};
    }

    // invoke insertNodes function with configured tasks
    insertNodes(nodeTasks, function(errN,resN)
    {
      if (errN)
      {
        self.crud.rollbackTransaction(transName,function(e)
        {
          callback(errN,null);
        });
      }

      /*
       * we have inserted new nodes, now we configure task to insert new arco
       */
      var tasks = {};

      // if one (or both) node has been inserted, we retrieve their id
      if (!nodeFromId)
        opt.object.newArcoAttrs.nodo_da = resN.nodeFrom.result.id;

      if (!nodeToId)
        opt.object.newArcoAttrs.nodo_a = resN.nodeTo.result.id;

      // build object to execute insert of new arco
      var newArcoOpt = {
        sysuser_id:opt.sysuser_id,
        transName: transName,
        object:opt.object,
        operation: "Creazione arco"
      };

      tasks.newArco = function(cb){insertArco(newArcoOpt,cb);};

      /*
       * configure tasks to break existing arco
       * (if we have inserted new nodes, and these nodes lies on existing arco,
       *  we have to break it)
       */
      if (arcoFromId)
      {
        var fromArcoOpt = {
          sysuser_id:opt.sysuser_id,
          transName: transName,
          object: {
            codArco:arcoFromId,
            idNodo:opt.object.newArcoAttrs.nodo_da,
            nodoCoords:opt.object.nodeFrom.coords,
            data:opt.object.newArcoAttrs.data_ini
          },
          operation: "Creazione arco"
        };

        tasks.breakFromArco = function(cb){breakArco(fromArcoOpt, cb);};
      }

      if (arcoToId)
      {
        var toArcoOpt = {
          sysuser_id:opt.sysuser_id,
          transName: transName,
          object: {
            codArco:arcoToId,
            idNodo:opt.object.newArcoAttrs.nodo_a,
            nodoCoords:opt.object.nodeTo.coords,
            data:opt.object.newArcoAttrs.data_ini
          },
          operation: "Creazione arco"
        };

        tasks.breakToArco = function(cb){breakArco(toArcoOpt, cb);};
      }

      // execute tasks to insert new arco and (eventually) break existing ones
      async.parallelLimit(tasks,1,function(errT,resT)
      {
        if (errT)
        {
          // manage tasks error
          self.log.error(self.moduleName + " - Error: " + errT.message);

          self.crud.rollbackTransaction(transName,function(e)
          {
            callback(errT,null);
          });
        }
        else
        {
          // add code of inserted nodes to response (to return them)
          if (!nodeFromId)
            resT.newArco.result.nodo_da = opt.object.newArcoAttrs.nodo_da;

          if (!nodeToId)
            resT.newArco.result.nodo_a = opt.object.newArcoAttrs.nodo_a;

          self.crud.commitTransaction(transName, function(e)
          {
            callback(e,e ? null : resT.newArco);
          });
        }
      });
    });
  });
}

// break arco at given coords
arco.prototype.break = function(opt, callback)
{
  /*
   * we have to:
   *
   * 1. insert new node with given coords
   * 2. break arco with inserted nodes
   *
   */

  var transName = "break_arco_" + new Date().getTime();

  // date is set to now
  var date = new Date();

  // Begin transaction
  self.crud.beginTransaction(transName, function(btErr)
  {
    if (btErr)
    {
      callback(btErr,null);
      return;
    }

    /*
     * Insert new nodo; query to execute:
     *
     * INSERT INTO grafo.nodo (data_ini, geom)
     * VALUES ($1, ST_SetSRID(ST_MakePoint($2,$3),<srid>))
     * RETURNING id
     *
     * (or VALUES ($1, ST_Transform(ST_SetSRID(ST_MakePoint($2,$3),<coords_srid>)),<table_srid>)
     * if coords are in different srid)
     */

    var nodo = (opt.object.srid != self.tableSrid) ?
      "ST_Transform("+
        "ST_SetSRID("+
          "ST_MakePoint(" + opt.object.x + ", " + opt.object.y + "), " +
          opt.object.srid +
        "), " +
        self.tableSrid +
      ")" :
      "ST_SetSRID("+
        "ST_MakePoint(" + opt.object.x + ", " + opt.object.y + "), " +
        opt.object.srid +
      ")";

    var qString =
      "INSERT INTO grafo.nodo (data_ini, geom) " +
      //"VALUES ('" + date.toCustomString() + "', " + nodo + ") " +
      "VALUES ($1, " + nodo + ") " +
      "RETURNING id;";

    var qOpt = {
      transName: transName,
      queryString: qString
    };

    self.crud.insert(qOpt, [{value:date}], function(errN,resN)
    {
      if (errN)
      {
        self.log.error(self.moduleName + " - Error on insert new nodo: " + errN.message);

        self.crud.rollbackTransaction(transName,function(e)
        {
          callback(errN,null);
        });
      }
      else
      {
        /*
         * break arco with given node; invoked function task:
         *
         * 1. break old arco with given node into two parts
         * 2. valorize some attribute of new parts with old values and some with new values
         * 3. set data_fine to old arco
         * 4. the civico of the old arco are assigned to the new ones
         */

        var arcoOpt = {
          transName: transName,
          object: {
            codArco:opt.object.codArco,
            idNodo:resN.result.id,
            nodoCoords:[opt.object.x, opt.object.y],
            data:date
          }
        };

        breakArco(arcoOpt, function(errA,resA)
        {
          if (errA)
          {
            self.log.error(self.moduleName + " - Error on break arco " +
              opt.object.id +": " + errA.message);

            self.crud.rollbackTransaction(transName,function(e)
            {
              callback(errA,null);
            });
          }
          else
          {
            // build object to return
            var obj = {
              nodo: resN.result.id,
              arco1: resA.insertArco1.result.cod_arco,
              arco2: resA.insertArco2.result.cod_arco,
            };

            self.crud.commitTransaction(transName, function(e)
            {
              callback(e,e ? null : {result:obj});
            });

            // write into log table new node data
            var change = [{
              key:'data_ini',
              new:date,
              old:null
            }];

            var logOpt = {
              object: [{
                user_id: opt.sysuser_id,
                entity: "nodo",
                entity_id: resN.result.id,
                operation: opt.operation || "Spezzamento arco - nuovo nodo",
                change: change
              }]
            };

            // write into log table new arco data
            if (resA.insertArco1)
            {
              var change = [];

              Object.keys(resA.insertArco1.result).forEach(function(key)
              {
                if (key != 'cod_arco' && resA.insertArco1.result[key])
                {
                  change.push({
                    key:key,
                    new:resA.insertArco1.result[key],
                    old:null
                  });
                }
              });

              var arcoLog = {
                user_id: opt.sysuser_id,
                entity: "arco",
                entity_id: resA.insertArco1.result.cod_arco,
                operation: opt.operation || "Spezzamento arco - nuovo arco",
                change: change
              };

              logOpt.object.push(arcoLog);
            }

            // write into log table new arco data
            if (resA.insertArco2)
            {
              var change = [];

              Object.keys(resA.insertArco2.result).forEach(function(key)
              {
                if (key != 'cod_arco' && resA.insertArco2.result[key])
                {
                  change.push({
                    key:key,
                    new:resA.insertArco2.result[key],
                    old:null
                  });
                }
              });

              var arcoLog = {
                user_id: opt.sysuser_id,
                entity: "arco",
                entity_id: resA.insertArco2.result.cod_arco,
                operation: opt.operation || "Spezzamento arco - nuovo arco",
                change: change
              };

              logOpt.object.push(arcoLog);
            }

            // write into log table old arco data
            if (resA.ceaseOld)
            {
              var change = [];

              change.push({
                key:'data_fine',
                new:resA.ceaseOld.result[0].data_fine,
                old:null
              });

              var arcoLog = {
                user_id: opt.sysuser_id,
                entity: "arco",
                entity_id: resA.ceaseOld.result[0].cod_arco,
                operation: opt.operation || "Spezzamento arco - arco cessato",
                change: change
              };

              logOpt.object.push(arcoLog);
            }

            /*if (resA.changeCivico)
            {
              for (var idx=0; idx<resA.changeCivico.length; idx++)
              {
                var change = [];

                change.push({
                  key:'cod_arco',
                  new:resA.changeCivico[idx].new_cod_arco,
                  old:resA.changeCivico[idx].cod_arco
                });

                var civicoLog = {
                  user_id: opt.sysuser_id,
                  entity: "civico",
                  entity_id: resA.changeCivico[idx].id,
                  operation: opt.operation || "Spezzamento arco - civico nuovo arco",
                  change: change
                };

                logOpt.object.push(civicoLog);
              }
            }*/

            self.entityHolder.getEntity("grafoLog").bulkInsert(
              logOpt,
              function(lErr,lRes){}
            );

          }
        });
      }
    });
  });
}

// merge two given arco removing given common node
arco.prototype.merge = function (opt, callback)
{
  /*
   * we have to:
   *
   * 1. remove given node
   * 2. remove given arco
   * 2. insert new arco (with geom = join geom of removed arco)
   *
   */

  // date is set to now
  var now = new Date();
  // data_fine is equal to data_ini of new arco (that is now) -1 day
  var dataFine = new Date(now.getTime()-86400*1000);

  var transName = "merge_arco_" + now.getTime();

  // Begin transaction
  self.crud.beginTransaction(transName, function(btErr)
  {
    if (btErr)
    {
      callback(btErr,null);
      return;
    }

    // object to write into log table
    var logOpt = {object: []};

    // configure tasks to remove node and archi
    var removeTasks = {};

    /*
     * Query to execute:
     *
     * UPDATE grafo.nodo
     * SET data_fine = <now-1day>
     * WHERE id = <idNodo>
     *
     * UPDATE grafo.arco
     * SET data_fine = <now-1day>, data_ri_mappa = <now-1day>
     * WHERE cod_arco = <codArco1>
     * RETURN nodo_da, nodo_a, cod_via_da, cod_via_a
     *
     * UPDATE grafo.arco
     * SET data_fine = <now-1day>, data_ri_mappa = <now-1day>
     * WHERE cod_arco = <codArco2>
     * RETURN nodo_da, nodo_a, cod_via_da, cod_via_a
     *
     * Note: values returned are used to obtain the corresponding values
     *       ​​to be inserted in the new arco
     */

    var qNodoOpt = {
      transName: transName,
      table:{schema:"grafo", name:"nodo"},
      fields:[{name:"data_fine"}],
      fieldType:{data_fine:self.crudUtils.TIMESTAMP},
      where:[{
        typeCond:self.crudUtils.SIMPLE_COND,
        leftSide:"id",
        operator:self.crudUtils.EQ,
        rightSide:opt.object.idNodo
      }]
    };

    // data_fine is equal to data_ini of new arco (that is now) -1 day
    var nodoVal = [{
      value: dataFine,
      type:self.crudUtils.TIMESTAMP
    }];

    var qArco1Opt = {
      transName: transName,
      table:{schema:"grafo", name:"arco"},
      fields:[{name:"data_fine"},{name:"data_ri_mappa"}],
      fieldType:{
        data_fine:self.crudUtils.TIMESTAMP,
        data_ri_mappa:self.crudUtils.TIMESTAMP
      },
      where:[{
        typeCond:self.crudUtils.SIMPLE_COND,
        leftSide:"cod_arco",
        operator:self.crudUtils.EQ,
        rightSide:opt.object.codArco1
      }],
      returning:[
        {name:"nodo_da"},
        {name:"nodo_a"},
        {name:"cod_via_da"},
        {name:"cod_via_a"}
      ]
    };

    // data_fine is equal to data_ini of new arco (that is now) -1 day
    var arco1Val = [
      {value: dataFine,type:self.crudUtils.TIMESTAMP},
      {value: dataFine,type:self.crudUtils.TIMESTAMP}
    ];

    var qArco2Opt = {
      transName: transName,
      table:{schema:"grafo", name:"arco"},
      fields:[{name:"data_fine"},{name:"data_ri_mappa"}],
      fieldType:{
        data_fine:self.crudUtils.TIMESTAMP,
        data_ri_mappa:self.crudUtils.TIMESTAMP
      },
      where:[{
        typeCond:self.crudUtils.SIMPLE_COND,
        leftSide:"cod_arco",
        operator:self.crudUtils.EQ,
        rightSide:opt.object.codArco2
      }],
      returning:[
        {name:"nodo_da"},
        {name:"nodo_a"},
        {name:"cod_via_da"},
        {name:"cod_via_a"}
      ]
    };

    // data_fine is equal to data_ini of new arco (that is now) -1 day
    var arco2Val = [
      {value: dataFine,type:self.crudUtils.TIMESTAMP},
      {value: dataFine,type:self.crudUtils.TIMESTAMP}
    ];

    removeTasks.nodo  = function(cb){self.crud.update(qNodoOpt,nodoVal,cb);};
    removeTasks.arco1 = function(cb){self.crud.update(qArco1Opt,arco1Val,cb);};
    removeTasks.arco2 = function(cb){self.crud.update(qArco2Opt,arco2Val,cb);};

    // execute tasks to remove entities
    async.parallelLimit(removeTasks,1,function(errD,resD)
    {
      if (errD)
      {
        // manage tasks error
        self.log.error(self.moduleName + " - Error: " + errD.message);

        self.crud.rollbackTransaction(transName,function(e)
        {
          callback(errD,null);
        });
      }
      else
      {
        // Add log entry for removed nodo and archi
        if(resD.nodo && resD.nodo.result)
        {
          logOpt.object.push({
            user_id: opt.sysuser_id,
            entity: "nodo",
            entity_id: opt.object.idNodo,
            operation: "Unione archi - rimozione nodo",
            change: [{
              key: "data_fine",
              new: dataFine,
              old: null
            }]
          });
        }

        if(resD.arco1 && resD.arco1.result)
        {
          logOpt.object.push({
            user_id: opt.sysuser_id,
            entity: "arco",
            entity_id: opt.object.codArco1,
            operation: "Unione archi - cessazione arco",
            change: [{
              key: "data_fine",
              new: dataFine,
              old: null
            },{
              key: "data_ri_mappa",
              new: dataFine,
              old: null
            }]
          });
        }

        if(resD.arco2 && resD.arco2.result)
        {
          logOpt.object.push({
            user_id: opt.sysuser_id,
            entity: "arco",
            entity_id: opt.object.codArco2,
            operation: "Unione archi - cessazione arco",
            change: [{
              key: "data_fine",
              new: dataFine,
              old: null
            },{
              key: "data_ri_mappa",
              new: dataFine,
              old: null
            }]
          });
        }

        // obtain nodo_da, nodo_a, cod_via_da and cod_via_a values ​​to be inserted in the new arco
        var nodo_da, nodo_a, cod_via_da, cod_via_a;

        if(resD.arco1 && resD.arco1.result)
        {
          if (resD.arco1.result[0].nodo_da == opt.object.idNodo)
          {
            nodo_a    = resD.arco1.result[0].nodo_a;
            cod_via_a = resD.arco1.result[0].cod_via_a;

            if (resD.arco2 && resD.arco2.result &&
                resD.arco2.result[0].nodo_a == opt.object.idNodo)
            {
              nodo_da    = resD.arco2.result[0].nodo_da;
              cod_via_da = resD.arco2.result[0].cod_via_da;
            }
          }
          else
          {
            nodo_da    = resD.arco1.result[0].nodo_da;
            cod_via_da = resD.arco1.result[0].cod_via_da;

            if (resD.arco2 && resD.arco2.result &&
                resD.arco2.result[0].nodo_da == opt.object.idNodo)
            {
              nodo_a    = resD.arco2.result[0].nodo_a;
              cod_via_a = resD.arco2.result[0].cod_via_a;
            }
          }
        }

        // now we have to insert new arco
        var mergeOpt = {
          transName: transName,
          userId: opt.sysuser_id,
          codArco1:opt.object.codArco1,
          codArco2:opt.object.codArco2,
          data:now,
          nodoDa: nodo_da || null,
          nodoA: nodo_a  || null,
          codViaDa: cod_via_da || null,
          codViaA: cod_via_a || null,
          logOpt: logOpt
        };

        mergeArchi(mergeOpt, function(errM, resM)
        {
          if (errM)
          {
            // manage tasks error
            self.log.error(self.moduleName + " - Error: " + errM.message);

            self.crud.rollbackTransaction(transName,function(e)
            {
              callback(errM,null);
            });
          }
          else
          {
            self.crud.commitTransaction(transName,function(e)
            {
              callback(e,e ? null : resM);

              if (!e && resM)
              {
                if (logOpt.object.length)
                {
                  self.entityHolder.getEntity("grafoLog").bulkInsert(
                    logOpt,
                    function(lErr,lRes){}
                  );
                }
              }
            });
          }
        });
      }
    });
  });
}

// rename an arco
arco.prototype.rename = function(opt, callback)
{
  /*
   * we have to:
   *
   * 1. update cod_via into given arco
   * 2. change via associated at civici on this arco
   * 3. if is necessary, record civici changes into civico_trac (based on id_mot_ridenominazione)
   *
   */

  // date is set to now
  var now = new Date();

  var transName = "rename_arco_" + now.getTime();

  // Begin transaction
  self.crud.beginTransaction(transName, function(btErr)
  {
    if (btErr)
    {
      callback(btErr,null);
      return;
    }

    // update codvia
    opt.object.cod_via = opt.object.cod_via_new;

    var idMotRidenominazione = opt.object.id_mot_ridenominazione;

    // remove unused object attributes
    delete opt.object.id_mot_ridenominazione;
    delete opt.object.cod_via_new;

    opt.transName = transName;
    opt.operation = "Ridenominazione arco";

    arco.super_.prototype.update.call(self,opt,function(err,res)
    {
      if (err)
      {
        self.crud.rollbackTransaction(transName,function(e)
        {
          callback(err,null);
        });

        return;
      }

      // look for all civici (valid and that aren't extensions) for given arco to renumber them
      var qCivicoArcoOpt = {
        transName: transName,
        fields:[
          {name:"id"},{name:"numero"},{name:"esponente"}
        ],
        from: [{name:"civico", schema:"grafo", type:self.crudUtils.TABLE}],
        where: [{
          typeCond: self.crudUtils.SIMPLE_COND,
          leftSide: "cod_arco",
          operator: self.crudUtils.EQ,
          rightSide: opt.id,
          nextCond: self.crudUtils.AND
        },{
          typeCond: self.crudUtils.SIMPLE_COND,
          leftSide: "data_fine",
          operator: self.crudUtils.IS,
          rightSide: null,
          nextCond: self.crudUtils.AND
        },{
          typeCond: self.crudUtils.SIMPLE_COND,
          leftSide: "estensione",
          operator: self.crudUtils.IS,
          rightSide: null
        }]
      };

      // execute query
      self.crud.select(qCivicoArcoOpt,[],function(errC,resC)
      {
        if (errC)
        {
          // manage error
          self.log.error(self.moduleName + " - Error on get all civico of arco " +
            opt.id + ": " + errC.message);

          self.crud.rollbackTransaction(transName,function(e)
          {
            callback(errC,null);
          });
        }
        else
        {
          var civicoEnt = self.entityHolder.getEntity("civico");

          var tasks = {};

          // build tasks to renumber founded civici
          for (var idx=0; idx<resC.result.length; idx++)
          {
            // if arco_mot_ridenominazione is 'bonifica solo sit', we set this value also for all civico renumber
            // otherwise set value to 'varie'
            // (values are in tables grafo.arco_mot_ridenominazione and grafo.civico_mot_inserimento)
            var renOpt = {
              sysuser_id: opt.sysuser_id,
              transName: transName,
              object: {
                data_ini: now.getTime(),
                data_fine: new Date(now.getTime() + 1*60000),
                id_mot_cessazione: 120, // Ridenominazione
                id_mot_inserimento: idMotRidenominazione == 3 ? 9 : 5,
                next_numero: resC.result[idx].numero,
                next_esponente: resC.result[idx].esponente,
                //next_cod_arco:opt.id,
                next_cod_via: opt.object.cod_via
              },
              id: resC.result[idx].id,
              operation: "Ridenominazione arco",
              noLog: false
            };

            createRenumberCivicoTask(idx, renOpt, tasks, civicoEnt);
          }

          // Exec civico renumber tasks
          async.parallelLimit(tasks,1,function(errCR,resCR)
          {
            var retObj = null;

            if (errCR)
            {
              // manage tasks error
              self.log.error(self.moduleName + " - Error: " + errCR.message);

              self.crud.rollbackTransaction(transName,function(e)
              {
                callback(errCR,null);
              });
            }
            else
            {
              retObj = {result: {}};

              for (var key in resCR)
                retObj.result[key] = resCR[key].result;

              self.crud.commitTransaction(transName, function(e)
              {
                callback(e,e ? null : retObj);
              });
            }

          });

        }
      });
    });

  });

}

/*
 * Export
 */
exports.arco = arco;

/*
 * Private function
 */
function insertArco(opt,callback)
{
  /*
   * Query to execute:
   *
   * INSERT INTO grafo.arco (data_ini, nodo_da, nodo_a, ...., geom)
   * VALUES (now, nodeFromId, nodeToId, ....,
   *    ST_SetSRID(ST_MakeLine(ARRAY[ST_MakePoint(x1,y1), ST_MakePoint(x2,y2), ... ]),<srid>))
   * RETURNING cod_arco
   *
   */
  var arco =
    "ST_SetSRID(" +
      "ST_MakeLine(ARRAY[";

  for (var idx=0; idx<opt.object.newArcoPoints.length; idx++)
  {
    arco += "ST_MakePoint(" + opt.object.newArcoPoints[idx][0] + ", " +
                              opt.object.newArcoPoints[idx][1] + ")";

    if (idx < opt.object.newArcoPoints.length -1)
      arco += ", ";
  }

  arco += "]), " + self.tableSrid + ")";

  var strListAttrs = "";
  var strListValues = "";
  var qVal = [];

  // cycle on attributes to build dinamically attrs and values list
  Object.keys(opt.object.newArcoAttrs).forEach(function(key)
  {
    strListAttrs += key + ", ";

    switch(key)
    {
      case 'data_ini':
        var dt = new Date(opt.object.newArcoAttrs[key]);
        //strListValues += "'" + dt.toCustomString() + "', ";
        strListValues += "$1, ";
        qVal.push({value:dt});
        break;

      default:
        strListValues += opt.object.newArcoAttrs[key] + ", ";
    }
  });

  strListAttrs  += "geom";
  strListValues += arco;

  var qString = "INSERT INTO grafo.arco (" + strListAttrs + ") " +
    "VALUES (" + strListValues + ") " +
    "RETURNING cod_arco;";

  var arcoOpt = {
    transName: opt.transName,
    queryString: qString
  };

  self.crud.insert(arcoOpt, qVal, function(errA,resA)
  {
    if (errA)
    {
      self.log.error(self.moduleName + " - Error on insert new arco: " + errA.message);

      callback(errA,null);
    }
    else
    {
      callback(null, resA);

      // write into log table
      var change = [];

      // cycle on input data to log their  values
      // (not for geoJSON [extra attributes])
      Object.keys(opt.object.newArcoAttrs).forEach(function(key)
      {
        change.push({
          key:key,
          new:opt.object.newArcoAttrs[key]
        });
      });

      var logOpt = {
        object: [{
          user_id: opt.sysuser_id,
          entity: "arco",
          entity_id: resA.result.cod_arco,
          operation: opt.operation,
          change: change
        }]
      };

      self.entityHolder.getEntity("grafoLog").bulkInsert(
        logOpt,
        function(lErr,lRes){}
      );
    }
  });
}

// execute task function to insert 1 or 2 nodes
function insertNodes(tasks, callback)
{
  if (Object.keys(tasks).length == 0)
    return callback(null,null);

  async.parallelLimit(tasks,1,function(err,res)
  {
    if (err)
    {
      // manage node tasks error
      self.log.error(self.moduleName + " - Error on insert new node: " + err.message);
    }

    callback(err,res);
  });
}

// break a given arco into two parts with given point and cease original arco
function breakArco(opt, callback)
{
  /*
   * we have to
   *
   * 1. break old arco with given node into two parts
   * 2. valorize some attribute of new parts with old values and some with new values
   * 3. set data_fine to old arco
   * 4. the civico of the old arco are assigned to the new ones (based on their projection)
   *
   */

  /*
   * Query to break given arco with given node:
   *
   * (we project [ST_ClosestPoint] given coords on given arco to be sure
   * that point is on arco and then snap [ST_Snap] arco to this point;
   * ST_Dump split returned geometry collection into two separate records
   *
   * SELECT (
   *   ST_Dump(
   *     ST_Split(
   *       ST_Snap(geom, ST_ClosestPoint(geom, ST_SetSRID(ST_MakePoint(<x>,<y>),<srid>)),0.1),
   *       ST_ClosestPoint(geom, ST_SetSRID(ST_MakePoint(<x>,<y>),<srid>))
   *     )
   *   )
   * ).geom
   * FROM grafo.arco
   * WHERE cod_arco = <cod_arco>
   *
   */

  var closestP = "ST_ClosestPoint(geom, " +
   "ST_SetSRID(" +
     "ST_MakePoint($1, $2)," +
     self.tableSrid + ")" +
   ")";

  var qString = "SELECT (ST_Dump(ST_Split(ST_Snap(geom," + closestP +",0.1)," +
    closestP + "))).geom " +
    "FROM grafo.arco WHERE cod_arco = $3";

  var qOpt = {
    sysuser_id:opt.sysuser_id,
    transName: opt.transName,
    queryString: qString
  };

  var qValue = [
    {value:opt.object.nodoCoords[0]},
    {value:opt.object.nodoCoords[1]},
    {value:opt.object.codArco}
  ];

  var geom1, geom2;

  // execute query to get geometries of two parts of given arco;
  // 1st part goes from nodo_da to new node
  // 2nd part goes from new node to nodo_a
  self.crud.select(qOpt, qValue, function(err,res)
  {
    if (res && res.result && res.result.length == 2)
    {
      geom1 = res.result[0].geom;
      geom2 = res.result[1].geom;

      // query to obtain all fields of table arco
      // (except geom, cod_arco, prev_arco, nodo_da, nodo_a,
      //  cod_via_da, cod_via_a, lunghezza and data_ini)
      qString =
        "SELECT array_to_string(" +
          "ARRAY(" +
            "SELECT column_name::text " +
            "FROM information_schema.columns " +
            "WHERE table_name = 'arco' AND table_schema = 'grafo' " +
            "AND column_name NOT IN('geom','cod_arco','prev_arco','lunghezza'," +
              "'nodo_da','nodo_a','cod_via_da','cod_via_a','data_ini') " +
          ")," +
          "','"+
        ") AS list_fields";

      qOpt = {
        sysuser_id:opt.sysuser_id,
        transName: opt.transName,
        queryString: qString
      };

      // execute query
      self.crud.select(qOpt,[],function(errL,resL)
      {
        if (resL && resL.result)
        {
          // list of grafo.arco fields
          var fieldList = resL.result[0].list_fields;

          var arcoTasks = {};

          // in 1st arco nodo_da and cod_via_da are preserved
          // nodo_a is new node and cod_via_a is set to null value
          // return all fields to write them into log
          var qInsertArco1Str =
            "INSERT INTO grafo.arco (" +
              fieldList + ",nodo_da,cod_via_da,data_ini,prev_arco,lunghezza," +
              "nodo_a,geom) " +
            "SELECT " + fieldList + "," +
                    "nodo_da," +
                    "cod_via_da," +
//                     "'" + new Date(opt.object.data).toCustomString() + "'," +
                    "$3," +
                    opt.object.codArco + ", " +
                    "round(ST_Length($1)::numeric,2)," +
                    "$2," + // nodo_a
                    "$1 " + // geom
            "FROM grafo.arco " +
            "WHERE cod_arco = " + opt.object.codArco +
            //" RETURNING cod_arco";
            " RETURNING " +fieldList + ",nodo_da,cod_via_da,data_ini,prev_arco,lunghezza,nodo_a,cod_arco";

          // configure 1st arco task
          var arco1Opt = {
            sysuser_id:opt.sysuser_id,
            transName: opt.transName,
            queryString: qInsertArco1Str
          };

          var arco1Val = [
            {value:geom1},
            {value:opt.object.idNodo},
            {value:new Date(opt.object.data)}
          ];

          arcoTasks.insertArco1 = function(cb){self.crud.insert(arco1Opt,arco1Val,cb);};

          // in 2nd arco nodo_a and cod_via_a are preserved
          // nodo_da is new node and cod_via_da is set to null value
          // return all fields to write them into log
          var qInsertArco2Str =
            "INSERT INTO grafo.arco (" +
              fieldList + ",nodo_a,cod_via_a,data_ini,prev_arco,lunghezza," +
              "nodo_da,geom) " +
            "SELECT " + fieldList + "," +
                    "nodo_a," +
                    "cod_via_a," +
//                     "'" + new Date(opt.object.data).toCustomString() + "'," +
                    "$3, " +
                    opt.object.codArco + "," +
                    "round(ST_Length($1)::numeric,2)," +
                    "$2," + // nodo_da
                    "$1 " + // geom
            "FROM grafo.arco " +
            "WHERE cod_arco = " + opt.object.codArco +
            //" RETURNING cod_arco";
            " RETURNING " +fieldList + ",nodo_a,cod_via_a,data_ini,prev_arco,lunghezza,nodo_da,cod_arco";


          // configure 2nd arco task
          var arco2Opt = {
            sysuser_id:opt.sysuser_id,
            transName: opt.transName,
            queryString: qInsertArco2Str
          };

          var arco2Val = [
            {value:geom2},
            {value:opt.object.idNodo},
            {value:new Date(opt.object.data)}
          ];

          arcoTasks.insertArco2 = function(cb){self.crud.insert(arco2Opt,arco2Val,cb);};

          // configure the task to cease the original arco
          /*
           * Query to execute:
           *
           * UPDATE grafo.arco
           * SET data_fine = <data>
           * WHERE cod_arco = <cod_arco>
           * RETURNING cod_arco, data_fine
           *
           */

          var qCeaseOpt = {
            transName: opt.transName,
            table: {name:"arco", schema:"grafo"},
            fields:[
              {name:"data_fine"}
            ],
            fieldType: {data_fine: self.crudUtils.TIMESTAMP},
            where: [{
              typeCond: self.crudUtils.SIMPLE_COND,
              leftSide: "cod_arco",
              operator: self.crudUtils.EQ,
              rightSide: opt.object.codArco
            }],
            returning:[
              {name:"cod_arco"},
              {name:"data_fine", type:self.crudUtils.TIMESTAMP}
            ]
          };

          // data_fine is equal to data_ini -1 day
          var qCeaseVal = [
            {value: new Date(opt.object.data-86400*1000), type:self.crudUtils.TIMESTAMP}
          ];

          arcoTasks.ceaseOld = function(cb){self.crud.update(qCeaseOpt,qCeaseVal,cb);};

          async.parallelLimit(arcoTasks,1,function(errA,resA)
          {
            if (errA)
            {
              // manage tasks error
              self.log.error(self.moduleName + " - Error: " + errA.message);

              callback(errA,null);
            }
            else
            {
              /*
               * associate civico numbers from the original arco
               * to the new ones based on the proximity to the same
               * (assign to arco where civico projection is)
               */

              // select all civico related to the original arco
              var qCivicoArcoOpt = {
                transName: opt.transName,
                fields:[
                  {name:"id"}
                ],
                from: [{name:"civico", schema:"grafo", type:self.crudUtils.TABLE}],
                where: [{
                  typeCond: self.crudUtils.SIMPLE_COND,
                  leftSide: "cod_arco",
                  operator: self.crudUtils.EQ,
                  rightSide: opt.object.codArco,
                  nextCond: self.crudUtils.AND
                },{
                  typeCond: self.crudUtils.SIMPLE_COND,
                  leftSide: "data_fine",
                  operator: self.crudUtils.IS,
                  rightSide: null
                }]
              };

              // execute query
              self.crud.select(qCivicoArcoOpt,[],function(errC,resC)
              {
                if (errC)
                {
                  // manage error
                  self.log.error(self.moduleName + " - Error on get all civico of arco " +
                    opt.object.codArco + ": " + errC.message);

                  callback(errC, null);
                }
                else
                {
                  // add other attributes to result to pass them to async function
                  for (var idx=0; idx<resC.result.length; idx++)
                  {
                    resC.result[idx].transName = opt.transName;
                    resC.result[idx].geom = geom1;
                    resC.result[idx].codArco1 = resA.insertArco1.result.cod_arco;
                    resC.result[idx].codArco2 = resA.insertArco2.result.cod_arco;
                  }

                  async.eachLimit(resC.result,1,ChangeCivicoArco,function(errU)
                  {
                    callback(errU,errU ? null : resA);
                  });
                }
              });
            }
          });
        }
        else
          callback(errL, null);
      });

    }
    else
    {
      var msg = "Error on break arco " + opt.object.codArco;
      msg += err ? ": " + err.message : "";

      self.log.error(self.moduleName + " - " + msg);

      callback({message:msg},null);
    }

  });
}

function ChangeCivicoArco(obj,callback)
{
  /*
   * Query to execute to update civico:
   * (to update with correct value, we check if civico projection is on given arco)
   *
   * UPDATE grafo.civico AS NEW
   * SET cod_arco = CASE
   *    WHEN
   *      ST_DWithin(<geom arco>, (ST_SetSRID(ST_MakePoint(<x>,<y>),<srid>)), 0.1) THEN <cod_arco_1>
   *    ELSE
   *      <cod_arco_2>
   * END
   * FROM grafo.civico AS OLD
   * WHERE id = <id> AND OLD.id = NEW.id
   * RETURNING OLD.id, OLD.cod_arco, NEW.cod_arco AS new_cod_arco
   *
   */
  var qStr =
    "UPDATE grafo.civico AS NEW SET cod_arco = CASE " +
    "WHEN ST_DWithin($1,(ST_SetSRID(ST_MakePoint(" +
    "OLD.proiezione_x, OLD.proiezione_y)," + self.tableSrid + ")), 0.1) THEN " +
    "$2::int ELSE " +
    "$3::int END " +
    "FROM grafo.civico AS OLD " +
    "WHERE OLD.id = $4::int AND OLD.id = NEW.id " +
    "RETURNING OLD.id, OLD.cod_arco, NEW.cod_arco AS new_cod_arco";

  var qOpt = {
    transName: obj.transName,
    queryString: qStr
  };

  var qVal = [
    {value:obj.geom},
    {value:obj.codArco1},
    {value:obj.codArco2},
    {value:obj.id}
  ];

  self.crud.update(qOpt,qVal,function(err,res)
  {
    callback(err);
  });
}

// merge two given archi
function mergeArchi(opt, callback)
{
  /*
   * we have to:
   *
   * 1. insert new arco (merge of arco1 and arco2)
   * 2. associate to new arco civici related to arco1 and arco2
   *
   */

  // query to obtain all fields of table arco
  // (except geom, cod_arco, prev_arco, prev_arco_suppl, nodo_da, nodo_a,
  //  cod_via_da, cod_via_a, lunghezza, data_ini, data_imm, data_fine, data_ri_mappa)
  var qString =
    "SELECT array_to_string(" +
      "ARRAY(" +
        "SELECT column_name::text " +
        "FROM information_schema.columns " +
        "WHERE table_name = 'arco' AND table_schema = 'grafo' " +
        "AND column_name NOT IN('geom','cod_arco','prev_arco'," +
          "'prev_arco_suppl','nodo_da','nodo_a','cod_via_da','cod_via_a'," +
          "'lunghezza','data_ini','data_imm','data_fine','data_ri_mappa') " +
      ")," +
      "','"+
    ") AS list_fields";

  var qOpt = {
    sysuser_id:opt.sysuser_id,
    transName: opt.transName,
    queryString: qString
  };

  self.crud.select(qOpt,[],function(err,res)
  {
    if (res && res.result)
    {
      // list of grafo.arco fields
      var fieldList = res.result[0].list_fields;

      // insert new merged arco
      // common values are taken from arco 1    TODO: it's right?
      // merged geometry is obtained as
      // SELECT ST_LineMerge(ST_SnapToGrid(ST_Collect(
      //    (SELECT geom FROM grafo.arco WHERE cod_arco = <codArco1>),
      //    (SELECT geom FROM grafo.arco WHERE cod_arco = <codArco2>)
      // ),0.001))
      var qInsertArcoStr =
        "INSERT INTO grafo.arco (" +
          fieldList + ",nodo_da,nodo_a,cod_via_da,cod_via_a,data_ini,data_imm," +
          "data_fine,data_ri_mappa,prev_arco,prev_arco_suppl,lunghezza,geom) " +
        "SELECT " + fieldList + "," +
                opt.nodoDa + "," +
                opt.nodoA + "," +
                opt.codViaDa + "," +
                opt.codViaA + "," +
//                 "'" + opt.data.toCustomString() + "'," +
//                 "'" + opt.data.toCustomString() + "'," +
                "$1," +
                "$2," +
                "null," +
                "null," +
                opt.codArco1 + ", " +
                opt.codArco2 + ", " +
                "(SELECT ROUND(SUM(ST_Length(geom))::numeric,2) FROM grafo.arco " +
                  "WHERE cod_arco IN (" + opt.codArco1 + "," + opt.codArco2 + "))," +
                "(SELECT ST_LineMerge(ST_SnapToGrid(ST_Collect(" +
                  "(SELECT geom FROM grafo.arco WHERE cod_arco = " + opt.codArco1 + ")," +
                  "(SELECT geom FROM grafo.arco WHERE cod_arco = " + opt.codArco2 + ")" +
                "),0.001))) " +
        "FROM grafo.arco " +
        "WHERE cod_arco = " + opt.codArco1 +
        " RETURNING cod_arco,lunghezza";

      var arcoOpt = {
        sysuser_id:opt.sysuser_id,
        transName: opt.transName,
        queryString: qInsertArcoStr
      };

      var arcoVal = [
        {value: opt.data},
        {value: opt.data}
      ];

      self.crud.insert(arcoOpt, arcoVal, function(errI,resI)
      {
        if (errI)
          callback(errI, null);
        else
        {
          // Add log entry for new arco
          opt.logOpt.object.push({
            user_id: opt.userId,
            entity: "arco",
            entity_id: resI.result.cod_arco,
            operation: "Unione archi - nuovo arco",
            change: [{
              key: "cod_arco",
              new: resI.result.cod_arco,
              old: null
            },{
              key: "nodo_da",
              new: opt.nodoDa,
              old: null
            },{
              key: "nodo_a",
              new: opt.nodoA,
              old: null
            },{
              key: "cod_via_da",
              new: opt.codViaDa,
              old: null
            },{
              key: "cod_via_a",
              new: opt.codViaA,
              old: null
            },
            {
              key: "data_ini",
              new: opt.data.getTime(),
              old: null
            },{
              key: "data_imm",
              new: opt.data.getTime(),
              old: null
            },{
              key: "prev_arco",
              new: opt.codArco1,
              old: null
            },{
              key: "prev_arco_suppl",
              new: opt.codArco2,
              old: null
            },{
              key: "lunghezza",
              new: resI.result.lunghezza,
              old: null
            }]
          });

          /*
           * Associate civico numbers from the original arco1 and arco2 to the new one
           * Query to execute:
           *
           * UPDATE grafo.civico
           * SET cod_arco = <cod_arco>
           * WHERE cod_arco IN (<cod_arco_1>, <cod_arco_2>)
           *
           */

          var qPar = ["$2","$3"];

          var civicoOpt = {
            transName: opt.transName,
            table:{schema:"grafo", name:"civico"},
            fields:[{name:"cod_arco"}],
            where:[
              {
                typeCond: self.crudUtils.SIMPLE_COND,
                leftSide: "cod_arco",
                operator: self.crudUtils.IN,
                rightSide: qPar.join(),
              }
            ],
            returning: [{name:"id"}],
            retOldVal: {id:"id"}
          };

          var civicoVal = [
            {value:resI.result.cod_arco},
            {value:opt.codArco1},
            {value:opt.codArco2}
          ];

          self.crud.update(civicoOpt, civicoVal, function(errU,resU)
          {
            if(errU)
              callback(errU,null);
            else
            {
              // Add log entry for updated civici
              for (var idx=0; idx<resU.result.length; idx++)
              {
                opt.logOpt.object.push({
                  user_id: opt.userId,
                  entity: "civico",
                  entity_id: resU.result[idx].id,
                  operation: "Unione archi - modifica codice arco",
                  change: [{
                    key: "cod_arco",
                    new: resI.result.cod_arco,
                    old: resU.result[idx].cod_arco
                  }]
                });
              }

              callback(null,resI);
            }
          })
        }
      });
    }
    else
      callback(err, null);
  });
}

// build task to reproject a civico on a reshaped arco
function createReprojectCivicoTask(idx, civico, cod_arco, tasks, civicoEnt, transName)
{
  var opt = {
    object:{
      x:civico.x,
      y:civico.y,
      cod_arco: cod_arco,
      id_civico: civico.id
    },
    transName: transName
  };

  tasks['civico_'+idx] = function(cb){civicoEnt.updateProjOnArco(opt, cb);};
}

// build task to renumber a civico on an arco rename
function createRenumberCivicoTask(idx, opt, tasks, civicoEnt)
{
  tasks['civico_'+idx] = function(cb){civicoEnt.renumber(opt, cb);};
}
