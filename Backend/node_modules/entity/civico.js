/*
 *    Date: 2018 10 11
 * Project: Nodas - EntityManager
 *
 * Copyright 2018 SIT srl
 */

var entTemp = require("./grafoLogger").grafoLogger;
var async = require("async");
var util = require("util");
var self = {};

// macro to manage check of presence of valid extensions on civico to delete
var _CIVICO_WITH_VALID_EXTENSIONS = "CIVICO_WITH_VALID_EXTENSIONS";
var _CIVICO_IS_EXTENSION = "CIVICO_IS_EXTENSION";
// macro to manage check of duplicate civico
var _DUPLICATE_CIVICO = "DUPLICATE_CIVICO";

var civico = function()
{
  civico.super_.call(this);

  this.moduleName = "Entity civico";
  this.entityName = "civico";
  this.schemaName = "grafo";
  this.tableName = "civico";
  this.tableSrid  = 32633;

  this.fieldTypeObj = {
    data_ini: this.crudUtils.TIMESTAMP,
    data_fine: this.crudUtils.TIMESTAMP,
    data_ri_mappa: this.crudUtils.TIMESTAMP,
    data_ins_mappa: this.crudUtils.TIMESTAMP,
    data_inserimento: this.crudUtils.TIMESTAMP
  };

  this.masterFieldObj = [
    {name: "id"},
    {name: "numero"},
    {name: "cod_via"},
    {name: "nome_via"},
    {name: "esponente"},
    {name: "estensione"},
    {name: "localita"},
    {name: "municipio"},
    {name: "data_fine"},
    {name: "x"},
    {name: "y"}
  ];

  this.entityId = "id";
  this.entityIdType = this.crudUtils.INTEGER;

  /*
   * Variables to manage the log into grafo.civico_trac table
   */

  // array of id that could assume id_mot_cessazione and id_mot_inserimento
  // that must be skipped on logging operation
  // (reference to tables grafo.civico_mot_inserimento and grafo.civico_mot_cessazione)
  this.idMotCessazioneToSkip  = [121];
  this.idMotInserimentoToSkip = [9];

  // from grafo.zona_tipo table
  this.idTipoZonaLocalita       = 1;
  this.idTipoZonaCircoscrizione = 3;
}

/*
 * Inheritance
 */
util.inherits(civico,entTemp);

civico.prototype.init = function(opt)
{
  self = this;
  civico.super_.prototype.init.call(self,opt);
}

civico.prototype.count = function(opt,callback)
{
  opt.tableName = "view_civico";
  civico.super_.prototype.count.call(self,opt,callback);
}

civico.prototype.master = function(opt,callback)
{
  opt.tableName = "view_civico";
  civico.super_.prototype.master.call(self,opt,callback);
}

civico.prototype.detail = function(opt,callback)
{
  opt.tableName = "view_civico";

  civico.super_.prototype.detail.call(self,opt,function(err,res)
  {
    if (err || !res.result)
    {
      callback(err,res);
      return;
    }

    /*
     * Get particelle for given civico
     */
    var civParEnt = self.entityHolder.getEntity("civicoParticelle");
    var civParOpt = {
      sysuser_id: opt.sysuser_id,
      object: {filter: "id_civico|EQ|"+opt.id}
    };

    civParEnt.master(civParOpt,function(cpErr,cpRes)
    {
      res.result.particelle = (cpRes && cpRes.result) ? cpRes.result : [];

      /*
       * Get zone for given civico:
       * SELECT * FROM grafo.view_civico_zona WEHERE id_civico = $1
       */
      var qOpt = {
        fields: self.crudUtils.ALL_FIELDS,
        from: [{
          schema: "grafo",
          name: "view_civico_zona",
          type: self.crudUtils.TABLE
        }],
        where: [{
          typeCond: self.crudUtils.SIMPLE_COND,
          leftSide: "id_civico",
          operator: self.crudUtils.EQ,
          rightSide: "$1",
        }]
      };

      self.crud.select(qOpt,[{value:opt.id}],function(zErr,zRes)
      {
        if (zRes && zRes.result)
          res.result.zone = zRes.result;

        /*
         * Get estensioni for given civico:
         * SELECT id, estensione, x, y
         * FROM grafo.view_civico
         * WHERE id_civico_principale = $1
         * AND (data_fine IS NULL OR data_fine > now)
         */
        qOpt = {
          fields: [{name:"id"},{name: "estensione"},{name: "x"},{name: "y"}],
          from: [{schema:"grafo",name:"view_civico",type:self.crudUtils.TABLE}],
          where: [
            {
              typeCond: self.crudUtils.SIMPLE_COND,
              leftSide: "id_civico_principale",
              operator: self.crudUtils.EQ,
              rightSide: "$1",
              nextCond: self.crudUtils.AND
            },
            {
              typeCond: self.crudUtils.COMPLEX_COND,
              conds:[
                {
                  typeCond: self.crudUtils.SIMPLE_COND,
                  leftSide: "data_fine",
                  operator: self.crudUtils.IS,
                  rightSide: null,
                  nextCond: self.crudUtils.OR
                },
                {
                  typeCond: self.crudUtils.SIMPLE_COND,
                  leftSide: "data_fine",
                  operator: self.crudUtils.GT,
                  rightSide: "$2"
                }
              ]
            }
          ]
        };

        var qVal = [
          {value: opt.id},
          {value: new Date().getTime(), type:self.crudUtils.TIMESTAMP}
        ];

        self.crud.select(qOpt,qVal,function(eErr,eRes)
        {
          if (eRes && eRes.result)
            res.result.estensioni = eRes.result;

          /*
           * Get cadastre info for id_edificio list:
           * SELECT id,sezione,foglio,numero FROM grafo.edificio
           * WHERE id IN (...)
           */
          res.result.catasto_edifici = [];

          if (!res.result.id_edificio || !res.result.id_edificio.length)
          {
            callback(null,res);
            return;
          }

          qOpt = {
            fields: [{name:"id"},{name:"sezione"},{name:"foglio"},{name:"numero"}],
            from: [{schema:"grafo",name:"edificio",type:self.crudUtils.TABLE}],
            where: [{
              typeCond: self.crudUtils.SIMPLE_COND,
              leftSide: "id",
              operator: self.crudUtils.IN,
              rightSide: res.result.id_edificio.join(),
            }]
          };

          self.crud.select(qOpt,[],function(cErr,cRes)
          {
            if (cRes && cRes.result)
              res.result.catasto_edifici = cRes.result;

            callback(null,res);
          });
        });
      });
    });
  });
}

civico.prototype.insert = function(opt,callback)
{
  var dupOpt = {
    cod_via: opt.object.cod_via,
    numero: opt.object.numero,
    esponente: opt.object.esponente,
    estensione: opt.object.estensione
  };

  // verify and set flag to skip duplicate check
  // insert could be invoked from other methods (renumber, ...)
  if (opt.skipCheck)
    dupOpt.skipCheck = true;

  // check if a civico with same cod_via, numero, esponente and estensione already exists
  checkDuplicate(dupOpt,function(errUN, resUN){
    if (errUN)
    {
      // exist already a civico with same parameters
      if (errUN.message == _DUPLICATE_CIVICO)
        callback(null,{result:{error:_DUPLICATE_CIVICO}});
      else
        callback(errUN,null);
    }
    else
    {
      // proceed with insert
      var trans = {
        fake: opt.transName != null,
        name: opt.transName || "InsCivico_" + new Date().getTime()
      };

      var id_zone = opt.object.id_zone;
      var particelle = opt.object.particelle;

      delete opt.object.id_zone;
      delete opt.object.particelle;

      /* Create transaction */
      beginTransaction(trans,function(bgErr)
      {
        if (bgErr)
        {
          callback(bgErr,null);
          return;
        }

        /* Insert civico */
        opt.transName = trans.name;

        civico.super_.prototype.insert.call(self,opt,function(iErr,iRes)
        {
          if (iErr)
          {
            rollbackTransaction(trans,function(e){callback(iErr,null);});
            return;
          }

          /*
           * tasks to execute:
           *
           * 1. insert particelle (if any)
           * 2. insert zone (if any)
           * 3. update municipio and localita of related via
           * 4. write into log
           */
          var tasks = {};

          if (particelle)
          {
            var pEnt = self.entityHolder.getEntity("civicoParticelle");
            var pOpt = {
              sysuser_id: opt.sysuser_id,
              transName: trans.name,
              object: particelle
            };

            for (var j = 0;j < particelle.length;j++)
              particelle[j].id_civico = iRes.result.id;

            tasks.insP = function(cb) {pEnt.bulkInsert(pOpt,cb);};
          }

          if (id_zone)
          {
            var zOpt = {
              transName: trans.name,
              fields: [{name:"id_zona"},{name:"id_civico"}],
              table: {schema:"grafo", name:"civico_zona"}
            };
            var zVal = [];

            for (var j = 0;j < id_zone.length;j++)
              zVal.push([{value:id_zone[j]},{value:iRes.result.id}]);

            tasks.insZ = function(cb) {self.crud.bulkInsert(zOpt,zVal,cb);};
          }

          // update municipio and localita of related via
          var qOpt =
          {
            transName: trans.name,
            fields: self.crudUtils.ALL_FIELDS,
            from: [{
              name: "manage_municipi_localita_via($1)",
              type: self.crudUtils.FUNCTION
            }]
          };

          tasks.updML = function(cb) {self.crud.select(qOpt,[{value: iRes.result.id}],cb);};

          // if noLog (insert operation came from civico renumber)
          // or if id_mot_inserimento belongs to idMotInserimentoToSkip array
          // we don't write record into civico_trac
          if (!opt.noLog &&
              (self.idMotInserimentoToSkip.indexOf(opt.object.id_mot_inserimento)) < 0)
          {
            var lOpt = {
              transName: trans.name,
              userId: opt.sysuser_id,
              id: iRes.result.id
            };

            // setting operation code from received value (if valued) or with default value
            var opCode = opt.logOpCode ? opt.logOpCode : "INC";

            tasks.insL = function(cb) {logOnCivicoTrac(opCode,lOpt,cb);};
          }

          /* Execute tasks */
          async.parallelLimit(tasks,1,function(err,res)
          {
            if (err)
              rollbackTransaction(trans,function(e){callback(err,null);});
            else
              commitTransaction(trans,function(e){callback(e,e ? null : iRes);});
          });
        });
      });
    }
  });

}

civico.prototype.update = function(opt,callback)
{
  var trans = {
    fake: opt.transName != null,
    name: opt.transName || "UpdCivico_" + new Date().getTime()
  };

  var id_zone = opt.object.id_zone;
  var particelle = opt.object.particelle;

  delete opt.object.id_zone;
  delete opt.object.particelle;

  /* Create transaction */
  beginTransaction(trans,function(bgErr)
  {
    if (bgErr)
    {
      callback(bgErr,null);
      return;
    }

    /* Update civico */
    opt.transName = trans.name;

    civico.super_.prototype.update.call(self,opt,function(uErr,uRes)
    {
      if (uErr || !uRes.result)
      {
        rollbackTransaction(trans,function(e){
          callback(uErr,null);
        });
        return;
      }

      /*
        * tasks to execute:
        *
        * 1. delete old particelle (if there is particelle array)
        * 2. insert new particelle (if there is particelle array and length > 0)
        * 3. delete old zone (if id_zone is valued)
        * 4. insert zone     (if id_zone is valued)
        * 5. update municipio and localita of related via
        * 6. write into log  (if opt.noLog is null or false and
        *                     if update is a civico cessation)
        */
      var tasks = {};

      if (particelle)
      {
        /* Delete old */
        var pdVal = [{value:opt.id}];
        var pdOpt = {
          transName: trans.name,
          table: {schema:"grafo", name:"civico_particelle"},
          where: [{
            typeCond: self.crudUtils.SIMPLE_COND,
            leftSide: "id_civico",
            operator: self.crudUtils.EQ,
            rightSide: "$1"
          }]
        };

        tasks.delP = function(cb) {self.crud.delete(pdOpt,pdVal,cb);};

        /* Insert new */
        if (particelle.length)
        {
          var pEnt = self.entityHolder.getEntity("civicoParticelle");
          var pOpt = {
            sysuser_id: opt.sysuser_id,
            transName: trans.name,
            object: particelle
          };

          tasks.insP = function(cb) {pEnt.bulkInsert(pOpt,cb);};
        }
      }

      if (id_zone)
      {
        /* Delete old zone */
        var dzOpt = {
          transName: trans.name,
          table: {schema:"grafo", name:"civico_zona"},
          where: [{
            typeCond: self.crudUtils.SIMPLE_COND,
            leftSide: "id_civico",
            operator: self.crudUtils.EQ,
            rightSide: "$1"
          }],
          returning: [{name:"id_zona"}]
        };

        var dzVal = [{value:opt.id}];

        tasks.delZ = function(cb) {self.crud.delete(dzOpt,dzVal,cb);};

        /* Insert new zone */
        var izOpt = {
          transName: trans.name,
          fields: [{name:"id_zona"},{name:"id_civico"}],
          table: {schema:"grafo", name:"civico_zona"}
        };
        var izVal = [];

        for (var j = 0;j < id_zone.length;j++)
          izVal.push([{value:id_zone[j]},{value:opt.id}]);

        tasks.insZ = function(cb) {self.crud.bulkInsert(izOpt,izVal,cb);};
      }

      // update municipio and localita of related via
      var qOpt =
      {
        transName: trans.name,
        fields: self.crudUtils.ALL_FIELDS,
        from: [{
          name: "manage_municipi_localita_via($1)",
          type: self.crudUtils.FUNCTION
        }]
      };

      tasks.updML = function(cb) {self.crud.select(qOpt,[{value: opt.id}],cb);};

      // if noLog (update operation came from civico renumber)
      // or if id_mot_cessazione belongs to idMotCessazioneToSkip array
      // we don't write record into civico_trac
      if (!opt.noLog)
      {
        var logOpt = {
          transName: trans.name,
          id: opt.id,
          userId: opt.sysuser_id
        };

        if (opt.object.data_fine &&
            opt.object.id_mot_cessazione &&
            self.idMotCessazioneToSkip.indexOf(opt.object.id_mot_cessazione) < 0)
        {
          tasks.wLog = function(cb){logOnCivicoTrac('CC', logOpt, cb);};
        }
        else
        {
          tasks.wLog = function(cb){logOnCivicoTrac('MC', logOpt, cb);};
        }
      }

//       if (!opt.noLog &&
//           opt.object.data_fine &&
//           opt.object.id_mot_cessazione &&
//           self.idMotCessazioneToSkip.indexOf(opt.object.id_mot_cessazione) < 0)
//       {
//         var logOpt = {
//           transName: trans.name,
//           id: opt.id,
//           userId: opt.sysuser_id
//         };
//
//         tasks.wLog = function(cb){logOnCivicoTrac('CC', logOpt, cb);};
//       }

      /* Execute tasks */
      async.parallelLimit(tasks,1,function(err,res)
      {
        if (err)
          rollbackTransaction(trans,function(e){callback(err,null);});
        else
          commitTransaction(trans,function(e){callback(e,e ? null : uRes);});
      });
    });
  });
}

civico.prototype.delete = function(opt,callback)
{
  // check if civico has valid extensions
  // (we could remove civico if it hasn't extensions)

  /*
   * Get estensioni for given civico:
   *
   * SELECT id
   * FROM grafo.view_civico
   * WHERE id_civico_principale = $1
   * AND data_fine IS NULL
   */
  var qOpt = {
    fields: [{name: "id"}],
    from: [{schema:"grafo",name:"view_civico",type:self.crudUtils.TABLE}],
    where: [{
      typeCond: self.crudUtils.SIMPLE_COND,
      leftSide: "id_civico_principale",
      operator: self.crudUtils.EQ,
      rightSide: "$1",
      nextCond: self.crudUtils.AND
    },{
      typeCond: self.crudUtils.SIMPLE_COND,
      leftSide: "data_fine",
      operator: self.crudUtils.IS,
      rightSide: null,
    }]
  };

  self.crud.select(qOpt,[{value:opt.id}],function(err,res)
  {
    if (err)
    {
      self.log.info(self.moduleName + " - Error on retrieve extensions for civico " +
        opt.id + ": " + err.message);

      callback(err,null);
    }
    else if (res.result.length > 0)
    {
      self.log.info(self.moduleName + " - civico " + opt.id + " has " +
        res.result.length + " extensions and could not be removed!");

      callback({message:_CIVICO_WITH_VALID_EXTENSIONS}, null);
    }
    else
    {
      self.log.info(self.moduleName + " - civico " + opt.id +
        " has no associated extension and could be removed");

      self.update(opt, callback);
    }
  });
}

/*
 * New methods
 */
civico.prototype.dictionaries = function(opt,callback)
{
  var tiEnt = self.entityHolder.getEntity("civicoTipoIngresso");
  var mcEnt = self.entityHolder.getEntity("civicoMotCessazione");
  var miEnt = self.entityHolder.getEntity("civicoMotInserimento");

  if (!tiEnt || !mcEnt || !miEnt)
  {
    callback({message:"Cannot retrieve dictionary entities"});
    return;
  }

  /* Prepare tasks */
  var masOpt = {sysuser_id:opt.sysuser_id, object:{ord:"name|ASC"}};

  var tasks = {
    ti: function(cb) {tiEnt.master(masOpt,cb);},
    mc: function(cb) {mcEnt.master(masOpt,cb);},
    mi: function(cb) {miEnt.master(masOpt,cb);}
  };

  /* Exec tasks */
  async.parallelLimit(tasks,1,function(err,res)
  {
    var retObj = null;

    if (!err && res)
    {
      retObj = {result: {
        tipoIngresso: res.ti.result,
        motCessazione: res.mc.result,
        motInserimento: res.mi.result
      }};
    }

    callback(err,retObj);
  });
}

// retrieve geographics attributes for a new civico given its coords
civico.prototype.retrieveGeoData = function(opt, callback)
{
  // arco geometries are in SR = 32633
  var arco_SRID = 32633;
  // edificio geometries are in SR = 32633
  var edificio_SRID = 32633;
  // zona geometries are in SR = 32633
  var zona_SRID = 32633;
  // cadastral geometries are in SR = 32633
  var catasto_SRID = 32633;

  var point_SRID = opt.object.srid;

  // check if we receive both coordinates
  if (!opt.object.x || !opt.object.y)
  {
    callback({message:"No coordinates provided"},null);
    return;
  }

  /*
   * We have to find:
   *
   * 1. the nearest arco (and related street) to the given coords;
   * 2. the nearest edificio (and its cadastral info) to the given coords
   * 3. località, municipio, circoscrizione, quartiere,
   *    sez censimento 2001,sez censimento 2011 in which the given point falls
   * 4. cadastral data in which the given point falls
   *
   * Query to execute (ST_X and ST_Y return coordinates of nearest point on arco):
   *
   * - point srid null or equal to arco table srid
   *
   *   SELECT ST_Distance(ST_ClosestPoint(ST_SetSRID(ST_MakePoint($1,$2),32633), a.geom), a.geom) AS dist,
   *          a.cod_arco, a.cod_via, v.denominazione,
   *          ST_X(ST_ClosestPoint(a.geom, ST_SetSRID(ST_MakePoint($1,$2),32633))) AS x,
   *          ST_Y(ST_ClosestPoint(a.geom, ST_SetSRID(ST_MakePoint($1,$2),32633))) AS y
   *   FROM grafo.arco a
   *   LEFT JOIN grafo.via v ON a.cod_via = v.cod_via
   *   WHERE a.data_fine IS NULL
   *   ORDER BY dist ASC
   *   LIMIT 1
   *
   *   SELECT ST_Distance(ST_ClosestPoint(ST_SetSRID(ST_MakePoint($1,$2),32633), e.geom), e.geom) AS dist,
   *       e.id, e.sezione, e.foglio, e.numero
   *   FROM grafo.edificio e
   *   WHERE e.data_fine IS NULL
   *   ORDER BY dist ASC
   *   LIMIT 1
   *
   *   SELECT z.id, z.gid, z.valore, z.descr, z.id_tipo, zt.name
   *   FROM grafo.zona z
   *   LEFT JOIN grafo.zona_tipo zt ON z.id_tipo = zt.id
   *   WHERE ST_Contains(z.geom, ST_SetSRID(ST_MakePoint($1,$2),32633))
   *
   *   SELECT vcp.gid,vcp.codice_comune,vcp.sezione,vcp.foglio,vcp.numero, vcp.allegato
   *   FROM catasto.view_catasto_particelle vcp
   *   WHERE ST_Contains(vcp.geom, ST_SetSRID(ST_MakePoint($1,$2), 32633))
   *
   *
   * - point srid different from zona table srid
   *
   *   SELECT ST_Distance(ST_ClosestPoint(ST_Transform(ST_SetSRID(ST_MakePoint($1,$2),$3), 32633), a.geom), a.geom) AS dist,
   *          a.cod_arco, a.cod_via, v.denominazione,
   *          ST_X(ST_ClosestPoint(a.geom, ST_Transform(ST_SetSRID(ST_MakePoint($1,$2),$3), 32633))) AS x,
   *          ST_Y(ST_ClosestPoint(a.geom, ST_Transform(ST_SetSRID(ST_MakePoint($1,$2),$3), 32633))) AS y
   *   FROM grafo.arco a
   *   LEFT JOIN grafo.via v ON a.cod_via = v.cod_via
   *   WHERE a.data_fine IS NULL
   *   ORDER BY dist ASC
   *   LIMIT 1
   *
   *   SELECT ST_Distance(ST_ClosestPoint(ST_Transform(ST_SetSRID(ST_MakePoint($1,$2),$3), 32633), e.geom), e.geom) AS dist,
   *       e.id, e.sezione, e.foglio, e.numero
   *   FROM grafo.edificio e
   *   WHERE e.data_fine IS NULL
   *   ORDER BY dist ASC
   *   LIMIT 1
   *
   *   SELECT z.id, z.gid, z.valore, zt.descr, z.id_tipo, zt.name
   *   FROM grafo.zona z
   *   LEFT JOIN grafo.zona_tipo zt ON z.id_tipo = zt.id
   *   WHERE ST_Contains(z.geom, ST_Transform(ST_SetSRID(ST_MakePoint($1,$2),$3), 32633))
   *
   *   SELECT vcp.gid,vcp.codice_comune,vcp.sezione,vcp.foglio,vcp.numero, vcp.allegato
   *   FROM catasto.view_catasto_particelle vcp
   *   WHERE ST_Contains(vcp.geom, ST_Transform(ST_SetSRID(ST_MakePoint($1,$2),$3), 32633))
   *
   */

  var pToRetrieveArco = (point_SRID != null && point_SRID != arco_SRID) ?
    "ST_Transform("+
      "ST_SetSRID("+
        "ST_MakePoint(" + opt.object.x + ", " + opt.object.y + "), " +
         point_SRID +
      "), " +
      arco_SRID +
    ")" :
    "ST_SetSRID("+
      "ST_MakePoint(" + opt.object.x + ", " + opt.object.y + "), " +
      arco_SRID +
    ")";

  var pToRetrieveEdificio = (point_SRID != null && point_SRID != edificio_SRID) ?
    "ST_Transform("+
      "ST_SetSRID("+
        "ST_MakePoint(" + opt.object.x + ", " + opt.object.y + "), " +
         point_SRID +
      "), " +
      edificio_SRID +
    ")" :
    "ST_SetSRID("+
      "ST_MakePoint(" + opt.object.x + ", " + opt.object.y + "), " +
      edificio_SRID +
    ")";

  var pToRetrieveZona = (point_SRID != null && point_SRID != zona_SRID) ?
    "ST_Transform("+
      "ST_SetSRID("+
        "ST_MakePoint(" + opt.object.x + ", " + opt.object.y + "), " +
         point_SRID +
      "), " +
      zona_SRID +
    ")" :
    "ST_SetSRID("+
      "ST_MakePoint(" + opt.object.x + ", " + opt.object.y + "), " +
      zona_SRID +
    ")";

  var pToRetrieveCadastre = (point_SRID != null && point_SRID != catasto_SRID) ?
    "ST_Transform("+
      "ST_SetSRID("+
        "ST_MakePoint(" + opt.object.x + ", " + opt.object.y + "), " +
         point_SRID +
      "), " +
      catasto_SRID +
    ")" :
    "ST_SetSRID("+
      "ST_MakePoint(" + opt.object.x + ", " + opt.object.y + "), " +
      catasto_SRID +
    ")";

  var queryArco =
    "SELECT ST_Distance(ST_ClosestPoint(" + pToRetrieveArco + ", a.geom), a.geom) AS dist, " +
    "a.cod_arco, a.cod_via, v.denominazione, " +
    "ST_X(ST_ClosestPoint(a.geom," + pToRetrieveArco + ")) AS x, " +
    "ST_Y(ST_ClosestPoint(a.geom," + pToRetrieveArco + ")) AS y " +
    "FROM grafo.arco a " +
    "LEFT JOIN grafo.via v ON a.cod_via = v.cod_via " +
    "WHERE a.data_fine IS NULL " +
    "ORDER BY dist ASC " +
    "LIMIT 1";

  var queryEdificio =
    "SELECT ST_Distance(ST_ClosestPoint(" + pToRetrieveEdificio + ", e.geom), e.geom) AS dist, " +
    "e.id, e.sezione, e.foglio, e.numero " +
    "FROM grafo.edificio e " +
    "WHERE e.data_fine IS NULL " +
    "ORDER BY dist ASC " +
    "LIMIT 1";

  var queryZone =
    "SELECT z.id, z.gid, z.valore, zt.descr, z.id_tipo, zt.name " +
    "FROM grafo.zona z " +
    "LEFT JOIN grafo.zona_tipo zt ON z.id_tipo = zt.id " +
    "WHERE ST_Contains(z.geom, " + pToRetrieveZona + ")";

  var queryCadastre =
    "SELECT vcp.gid,vcp.codice_comune,vcp.sezione,vcp.foglio,vcp.numero,vcp.allegato " +
    "FROM catasto.view_catasto_particelle vcp " +
    "WHERE ST_Contains(vcp.geom, " + pToRetrieveCadastre + ")";

  // Exec query
  self.crud.select({queryString:queryArco},[],function(errA, resA)
  {
    if (errA || !resA.result || resA.result.length == 0)
    {
      var msg = "Error on retrieve nearest arco for coordinate (" +
        opt.object.x + ", " + opt.object.y + ")";

      var logMsg = msg + (errA ? ": " + errA.message : "");

      self.log.error(self.moduleName + " - " + logMsg);

      return callback({message:msg}, null);
    }
    else
    {
      self.crud.select({queryString:queryEdificio},[],function(errE, resE)
      {
        if (errE || !resE.result || resE.result.length == 0)
        {
          var msg = "Error on retrieve nearest edificio for coordinate (" +
            opt.object.x + ", " + opt.object.y + ")";

          var logMsg = msg + (errE ? ": " + errE.message : "");

          self.log.error(self.moduleName + " - " + logMsg);

          return callback({message:msg}, null);
        }
        else
        {
          self.crud.select({queryString:queryZone},[],function(errZ, resZ)
          {
            if (errZ || !resZ.result || resZ.result.length == 0)
            {
              var msg = "Error on retrieve zone for coordinate (" +
                opt.object.x + ", " + opt.object.y + ")";

              var logMsg = msg + (errZ ? ": " + errZ.message : "");

              self.log.error(self.moduleName + " - " + logMsg);

              return callback({message:msg}, null);
            }
            else
            {
              self.crud.select({queryString:queryCadastre},[], function(errC,resC)
              {
                if (errC || !resC.result)
                {
                  var msg = "Error on retrieve cadastral info for coordinate (" +
                    opt.object.x + ", " + opt.object.y + ")";

                  var logMsg = msg + (errC ? ": " + errC.message : "");

                  self.log.error(self.moduleName + " - " + logMsg);

                  return callback({message:msg}, null);
                }
                else
                {
                  // format result
                  var ret = {
                    cod_arco: resA.result[0].cod_arco,
                    cod_via: resA.result[0].cod_via,
                    id_edificio: resE.result[0].id,
                    catasto_edifici: [{
                      id: resE.result[0].id,
                      sezione: resE.result[0].sezione,
                      foglio: resE.result[0].foglio,
                      numero: resE.result[0].numero
                    }],
                    denominazione: resA.result[0].denominazione,
                    nearest_point:[resA.result[0].x, resA.result[0].y],
                    particelle:[],
                    zone:[]
                  };

                  // add cadastral info if present
                  // (if point is on road, queryCadastre returns nothing)
                  if (resC.result.length > 0)
                  {
                    ret.particelle.push({
                      sezione: resC.result[0].sezione,
                      allegato: resC.result[0].allegato,
                      foglio: resC.result[0].foglio+'', // convert to string
                      numero: resC.result[0].numero
                    })
                  }

                  for (var idx=0; idx<resZ.result.length; idx++)
                  {
                    ret.zone.push({
                      id_zona:resZ.result[idx].id,
                      id_tipo: resZ.result[idx].id_tipo,
                      name: resZ.result[idx].name,
                      descr: resZ.result[idx].descr,
                      valore: resZ.result[idx].valore,
                    });
                  }

                  return callback(null, {result:ret});
                }
              });

            }
          });
        }
      });
    }
  });
}

// retrieve projection of a point (civico) on given arco
civico.prototype.retrieveProjOnArco = function(opt, callback)
{
  // check if we receive both coordinates
  if (!opt.object.x || !opt.object.y || !opt.object.cod_arco)
  {
    callback({message:"No input parameters provided"},null);
    return;
  }

  /*
   *
   * Query to execute (ST_X and ST_Y return coordinates of nearest point on arco):
   * (arco and given point have same geometries srid)
   *
   *  SELECT a.cod_via, v.denominazione AS nome_via,
   *         ST_X(ST_ClosestPoint(a.geom, ST_SetSRID(ST_MakePoint($1, $2),32633))) AS proiezione_x,
   *         ST_Y(ST_ClosestPoint(a.geom, ST_SetSRID(ST_MakePoint($1, $2),32633))) AS proiezione_y
   *  FROM grafo.arco a
   *  LEFT JOIN grafo.via v ON a.cod_via = v.cod_via
   *  WHERE a.cod_arco = $2
   *
   */

  var pToRetrieve =
    "ST_SetSRID(ST_MakePoint(" + opt.object.x + ", " + opt.object.y + "), 32633)";

  var queryArco =
    "SELECT a.cod_via, v.denominazione AS nome_via, " +
    "ST_X(ST_ClosestPoint(a.geom," + pToRetrieve + ")) AS proiezione_x, " +
    "ST_Y(ST_ClosestPoint(a.geom," + pToRetrieve + ")) AS proiezione_y " +
    "FROM grafo.arco a " +
    "LEFT JOIN grafo.via v ON a.cod_via = v.cod_via " +
    "WHERE a.cod_arco=" + opt.object.cod_arco;

  var qOpt = {queryString:queryArco};

  if (opt.transName)
    qOpt.transName = opt.transName;

  // Exec query
  self.crud.select(qOpt, [], function(err, res)
  {
    if (err || !res.result || res.result.length == 0)
    {
      var msg = "Error on retrieve projection of point with coords (" +
        opt.object.x + ", " + opt.object.y + ") on arco " + opt.object.cod_arco;

      var logMsg = msg + (err ? ": " + err.message : "");

      self.log.error(self.moduleName + " - " + logMsg);

      return callback({message:msg}, null);
    }
    else
    {
      res.result[0].proiezione_x = res.result[0].proiezione_x.toFixed(2) * 1;
      res.result[0].proiezione_y = res.result[0].proiezione_y.toFixed(2) * 1;

      return callback(null, {result:res.result[0]});
    }
  });
}

// update projection of a point (civico) on given arco
civico.prototype.updateProjOnArco = function(opt, callback)
{
  // check input parameters
  if (!opt.object.x || !opt.object.y || !opt.object.cod_arco)
  {
    callback({message:"No input parametes provided"},null);
    return;
  }

  civico.prototype.retrieveProjOnArco(opt, function(err,res)
  {
    if (err)
    {
      callback(err,null);
    }
    else
    {
      /*
       * Query to execute:
       * (we don't invoke civico update method to avoid to update also other fields such as zone)
       *
       * UPDATE grafo.civico SET proiezione_x = $1, proiezione_y = $2 WHERE id = $3
       *
       */

      var qOpt = {
        transName: opt.transName,
        table: {schema:"grafo", name:"civico"},
        fields:[
          {name:"proiezione_x"},
          {name:"proiezione_y"}
        ],
        where:[{
          typeCond:self.crudUtils.SIMPLE_COND,
          leftSide: "id",
          operator: self.crudUtils.EQ,
          rightSide: "$3"
        }]
      };

      var qVal = [
        {value: res.result.proiezione_x},
        {value: res.result.proiezione_y},
        {value: opt.object.id_civico}
      ];

      self.crud.update(qOpt, qVal, function(errU,resU)
      {
        if (errU)
        {
          self.log.error(self.moduleName + " - Error on update civico projections: " + errU.message);
        }

        callback(errU, resU);
      });
    }
  });
}

// renumber on civico
civico.prototype.renumber = function(opt,callback)
{
  /*
   * we have to:
   *
   * 1. retrieve given civico details (if it is an extensions could not be removed)
   *
   * 2. insert new civico (and related zones) with:
   *    -  data of current civico
   *    -  data_ini, id_mot_inserimento, numero, esponente and prev_civico
   *       (and also cod_arco and cod_via if changed) from received params
   *
   * 3. update given civico (to cease it) with:
   *    -  data_fine, id_mot_cessazione from received params
   *
   */

  // retrieve civico details
  self.detail(opt,function(errD,resD)
  {
    if (errD || !resD.result)
    {
      var msg = "Error on retrieve details for civico " + opt.id;

      var logMsg = msg + (errD ? ": " + errD.message : "");

      self.log.error(self.moduleName + " - " + logMsg);

      return callback({message:msg}, null);
    }
    else if (resD.result.estensione)
    {
      self.log.info(self.moduleName + " - civico " + opt.id +
        " is an extensions and could not be renumbered!");

      callback({message:_CIVICO_IS_EXTENSION}, null);
    }
    else
    {
      // check if into renumber operation cod_arco is changed
      var codArcoIsChanged = opt.object.next_cod_arco != null;

      // check if only cod_via is changed (civico renumber come from arco rename)
      //var codViaIsChanged = !codArcoIsChanged && (opt.object.next_cod_via != null);
      var codViaIsChanged = opt.object.next_cod_via != null;

      // check if a civico with same cod_via, numero, esponente and estensione already exists
      var dupOpt = {
        cod_via   : codViaIsChanged ? opt.object.next_cod_via : resD.result.cod_via,
        numero    : opt.object.next_numero,
        esponente : opt.object.next_esponente,
        estensione: resD.result.estensione
      };

      // in this case (civico renumber consists only in change arco on same via)
      // check duplicate is not necessary
      if (resD.result.numero    == opt.object.next_numero    &&
          resD.result.esponente == opt.object.next_esponente &&
          resD.result.cod_via   == opt.object.next_cod_via   &&
          resD.result.cod_arco  != opt.object.next_cod_arco)
      {
        dupOpt.skipCheck = true;
        self.log.info(self.moduleName + " - check duplicate isn't necessary in this case; " +
          "civico renumber consists only in change arco on same via");
      }

      checkDuplicate(dupOpt, function(errUN, resUN){
        if (errUN)
        {
          if (errUN.message == _DUPLICATE_CIVICO)
            callback({message:_DUPLICATE_CIVICO}, null);
          else
            callback(errUN,null);
        }
        else
        {
          // elaborate received data

          // save estensioni array before to remove it from results
          var estensioni = resD.result.estensioni;

          // remove attributes that not must be saved on new civico
          delete resD.result.id;
          delete resD.result.nome_via;
          delete resD.result.localita;
          delete resD.result.municipio;
          delete resD.result.data_fine;
          delete resD.result.id_edificio_str;
          delete resD.result.estensioni;
          delete resD.result.particelle;
          delete resD.result.catasto_edifici;
          delete resD.result.is_valid_now;

          if (!resD.result.data_ri_mappa)
            delete resD.result.data_ri_mappa;

          // set zone array to insert into civico_zona table
          resD.result.id_zone = [];

          if (resD.result.zone)
          {
            for (var idx=0; idx<resD.result.zone.length; idx++)
              resD.result.id_zone.push(resD.result.zone[idx].id_zona);

            delete resD.result.zone;
          }

          // set attributes from received params
          resD.result.data_ini           = opt.object.data_ini;
          resD.result.numero             = opt.object.next_numero;
          resD.result.esponente          = opt.object.next_esponente;
          resD.result.id_mot_inserimento = opt.object.id_mot_inserimento;
          resD.result.prev_civico        = opt.id;

          // if cod_arco is changed, add in attributes to insert also new cod_arco
          // (also cod_via could be changed with cod_arco) and projection of civico
          // on this arco
          if (codArcoIsChanged)
          {
            resD.result.cod_arco     = opt.object.next_cod_arco;
            resD.result.cod_via      = opt.object.next_cod_via;
            resD.result.proiezione_x = opt.object.proiezione_x;
            resD.result.proiezione_y = opt.object.proiezione_y;
          }

          // if only cod_via is changed (civico renumber come from arco rename) add next_cod_via in attributes
          if (codViaIsChanged)
          {
            resD.result.cod_via = opt.object.next_cod_via;
          }

          // save params for next update query before to overwrite opt.object
          var data_fine         = opt.object.data_fine;
          var id_mot_cessazione = opt.object.id_mot_cessazione;

          // begin a transaction
          var trans = {
            name: opt.transName || "RenumberCivico_" + new Date().getTime(),
            fake: opt.transName != null
          };

          beginTransaction(trans, function(err)
          {
            if (err)
              return callback(err, null);

            opt.transName = trans.name;
            opt.object    = resD.result;

            // remove not valorized keys (previous detail return all fields)
            Object.keys(opt.object).forEach(function(key)
            {
              if (!opt.object[key])
                delete opt.object[key];
            });

//             // set attribute to avoid to log this insert operation into civico_trac (tipo_op = INC)
//             // we log renumber operation at the end
//             opt.noLog = true;

            // set operation code to log this civico insert
            opt.logOpCode = 'SC';

            // set right operation to log
            opt.operation = opt.operation || "Rinumerazione Civico";

            // if we have skip civico duplicate check, we have also skip it on insert operation
            if (dupOpt.skipCheck)
              opt.skipCheck = true;

            // execute insert new civico
            self.insert(opt,function(errI,resI)
            {
              if (errI || !resI.result)
              {
                rollbackTransaction(trans, function(rollErr)
                {
                  callback(errI, null);
                });
              }
              else
              {
                // execute update of current civico to cease it

                // set attributes to update on current civico
                opt.object = {
                  data_fine:         data_fine,
                  id_mot_cessazione: id_mot_cessazione
                }

//                 // set attribute to avoid to log this update operation into civico_trac (tipo_op = CC)
//                 // we log renumber operation at the end of this procedure
//                 opt.noLog = true;

                // reset operation code
                opt.logOpCode = null;

                // set right operation to log
                opt.operation = opt.operation || "Rinumerazione Civico";

                // update current civico (to cease it)
                self.update(opt, function(errU, resU)
                {
                  if (errU)
                  {
                    rollbackTransaction(trans, function(rollErr)
                    {
                      callback(errU, null);
                    });
                  }
                  else
                  {
                    var reOpt = {
                      sysuser_id: opt.sysuser_id,
                      transName: trans.name,
                      estensioni:estensioni,
                      numero:resD.result.numero,
                      esponente:resD.result.esponente,
                      id_civico_principale:resI.result.id,
                      codArcoIsChanged:codArcoIsChanged,
                      codViaIsChanged: codViaIsChanged,
                      operation: opt.operation
                    };

                    if (codArcoIsChanged)
                    {
                      reOpt.cod_arco = resD.result.cod_arco;
                      reOpt.cod_via  = resD.result.cod_via;
                    }

                    if (codViaIsChanged)
                    {
                      reOpt.cod_via = resD.result.cod_via;
                    }

                    // renumber also civico extensions
                    // doesn't log into civico_trac; is correct?
                    renumberExtensions(reOpt, function(errRE,resRE)
                    {
                      if(errRE)
                      {
                        rollbackTransaction(trans, function(rollErr)
                        {
                          callback(errI, null);
                        });
                      }
                      else
                      {
                        commitTransaction(trans,function(e){callback(e,e ? null : resU);});
                      }

//                       // if id_mot_inserimento belongs to idMotInserimentoToSkip array
//                       // we don't write record into civico_trac
//                       if (self.idMotInserimentoToSkip.indexOf(resD.result.id_mot_inserimento) < 0)
//                       {
//                         var logOpt = {
//                           transName: trans.name,
//                           id: resI.result.id,
//                           userId: opt.sysuser_id
//                         };
//
//                         logOnCivicoTrac("SC", logOpt, function(errLog, resLog)
//                         {
//                           if (errLog)
//                             rollbackTransaction(trans,function(e){callback(errLog,null);});
//                           else
//                             commitTransaction(trans,function(e){callback(e,e ? null : resU);});
//                         });
//                       }
//                       else
//                       {
//                         commitTransaction(trans,function(e){callback(e,e ? null : resU);});
//                       }

                    });
                  }
                });
              }
            });
          });

        }
      });

    }
  });
}

/*
 * Export
 */
exports.civico = civico;

/*
 * Private function
 */
function beginTransaction(opt,callback)
{
  opt.fake ? callback(null) : self.crud.beginTransaction(opt.name,callback);
}

function commitTransaction(opt,callback)
{
  opt.fake ? callback(null) : self.crud.commitTransaction(opt.name,callback);
}

function rollbackTransaction(opt,callback)
{
  opt.fake ? callback(null) : self.crud.rollbackTransaction(opt.name,callback);
}

function checkDuplicate(opt,callback)
{
  // in this case we have not execute this control
  if (opt.skipCheck)
    return callback(null,null);

  // check if a civico with same cod_via, numero, esponente and estensione already exists

  /*
   * Query to execute:
   *
   * SELECT id, data_fine
   * FROM grafo.civico
   * WHERE cod_via = $1 AND numero = $2 AND esponente = $3 AND estensione = $4
   *
   */

  var paramIdx = 1;

  var qOpt = {
    fields:[
      {name:'id'},{name:'data_fine'}
    ],
    fieldType: {data_fine:self.crudUtils.TIMESTAMP},
    from:[
      {schema:'grafo', name:'civico', type:self.crudUtils.TABLE}
    ],
    where:[
      {
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: 'cod_via',
        operator: self.crudUtils.EQ,
        rightSide: '$'+paramIdx++,
        nextCond: self.crudUtils.AND
      },
      {
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: 'numero',
        operator: self.crudUtils.EQ,
        rightSide: '$'+paramIdx++,
        nextCond: self.crudUtils.AND
      },
      {
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: 'esponente',
        operator: opt.esponente ? self.crudUtils.EQ : self.crudUtils.IS,
        rightSide: opt.esponente ? '$'+paramIdx++ : null,
        nextCond: self.crudUtils.AND
      },
      {
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: 'estensione',
        operator: opt.estensione ? self.crudUtils.EQ : self.crudUtils.IS,
        rightSide: opt.estensione ? '$'+paramIdx++ : null
      }
    ]
  };

  var qVal = [{value:opt.cod_via}, {value:opt.numero}];

  if (opt.esponente)  qVal.push({value:opt.esponente});
  if (opt.estensione) qVal.push({value:opt.estensione});

  self.crud.select(qOpt, qVal, function(err, res)
  {
    var existValidCivico = false;

    if (err)
    {
      self.log.error(self.moduleName + " - Error on select civico info: " + errUN.message);
      callback(err,null);
    }
    else if (res.result.length > 0)
    {
      for (var idx=0; idx<res.result.length; idx++)
      {
        if (!res.result[idx].data_fine)
          existValidCivico = true;
      }

      if (!existValidCivico)
      {
        self.log.info(self.moduleName +
          " - found one or more civico with same key parameters, but they have all ceased");
        callback(null,null);
      }
      else
      {
        callback({message:_DUPLICATE_CIVICO},null);
      }
    }
    else
    {
      callback(null,null);
    }
  });
}

// method to renumber civico extensions (on main civico renumber)
function renumberExtensions(opt, callback)
{
  if (opt.estensioni.length == 0)
  {
    self.log.info(self.moduleName + " - this civico has no extensions to be renumbered");
    return callback(null,null);
  }

  /*
   * Renumber (update) also related extensions.
   * Query to execute:
   *
   * UPDATE grafo.civico AS c
   * SET numero = <numero>, esponente = <esponente>,
   *     id_civico_principale = <id_civico_principale>,
   *     cod_arco = <cod_arco>, cod_via = <cod_via>,
   *     proiezione_x = <proiezione_x>,
   *     proiezione_y = <proiezione_y>
   * WHERE id IN <list_id>
   *
   * cod_arco, cod_via, proiezione_x and proiezione_y are present
   * into update only if cod_arco is changed into renumbering.
   * In this case proiezione_x and proiezione_y are valued as:
   *
   * SELECT
   * ROUND(ST_X(ST_ClosestPoint(a.geom,c.geom))::numeric,2) AS prx
   * FROM grafo.arco a
   * LEFT JOIN grafo.via v ON a.cod_via = v.cod_via
   * WHERE a.cod_arco=<cod_arco>
   *
   * SELECT
   * ROUND(ST_Y(ST_ClosestPoint(a.geom,c.geom))::numeric,2) AS pry
   * FROM grafo.arco a
   * LEFT JOIN grafo.via v ON a.cod_via = v.cod_via
   * WHERE a.cod_arco=<cod_arco>
   *
   */

  var qVal = [];
  var qPar = [];

  qVal.push({value:opt.numero});
  qVal.push({value:opt.esponente});
  qVal.push({value:opt.id_civico_principale});

  var numVal = 3;

  var qStr =
    "UPDATE grafo.civico AS NEW SET numero = $1, esponente = $2," +
    "id_civico_principale = $3";

  if (opt.codArcoIsChanged)
  {
    qStr +=
      ",cod_arco = $4, cod_via = $5," +
      "proiezione_x=(SELECT " +
      "ROUND(ST_X(ST_ClosestPoint(a.geom,NEW.geom))::numeric,2) AS prx " +
      "FROM grafo.arco a " +
      "LEFT JOIN grafo.via v ON a.cod_via = v.cod_via " +
      "WHERE a.cod_arco=$4)," +
      "proiezione_y=(SELECT " +
      "ROUND(ST_Y(ST_ClosestPoint(a.geom,NEW.geom))::numeric,2) AS pry " +
      "FROM grafo.arco a " +
      "LEFT JOIN grafo.via v ON a.cod_via = v.cod_via " +
      "WHERE a.cod_arco=$4) ";

    qVal.push({value:opt.cod_arco});
    qVal.push({value:opt.cod_via});

    numVal = 5;
  }

  if (opt.codViaIsChanged)
  {
    qStr +=
      ", cod_via = $4 ";

    qVal.push({value:opt.cod_via});

    numVal = 4;
  }

  // Add condition to return pre-updated values
  qStr += " FROM grafo.civico AS OLD";

  for (var idx=0; idx<opt.estensioni.length; idx++)
  {
    qPar.push("$"+(idx+numVal+1));
    qVal.push({value:opt.estensioni[idx].id});
  }

  qStr += " WHERE OLD.id IN (" + qPar.join() + ")";

  // Add condition to return pre-updated values
  qStr += " AND NEW.id = OLD.id ";
  qStr += "RETURNING OLD.id, OLD.numero, OLD.esponente, OLD.id_civico_principale";

  if (opt.codArcoIsChanged)
  {
    qStr += ", OLD.cod_arco, OLD.cod_via, OLD.proiezione_x AS opx, OLD.proiezione_y AS opy, NEW.proiezione_x AS npx, NEW.proiezione_y AS npy";
  }

  if (opt.codViaIsChanged)
  {
    qStr += ", OLD.cod_via";
  }

  var qOpt = {
    transName: opt.transName,
    queryString: qStr
  };

  self.crud.update(qOpt, qVal, function(err, res)
  {
    if (err)
    {
      self.log.error(self.moduleName + " - " + err.message);
    }

    callback(err,res);

    // write into log table
    if (res.result)
    {
      for (var idx=0; idx<res.result.length; idx++)
      {
        var itemRes = res.result[idx];
        var change = [];

        if (itemRes.numero != opt.numero)
          change.push({
            key:'numero',
            new:opt.numero,
            old:itemRes.numero
          });

        if (itemRes.esponente != opt.esponente)
          change.push({
            key:'esponente',
            new:opt.esponente,
            old:itemRes.esponente
          });

        if (itemRes.id_civico_principale != opt.id_civico_principale)
          change.push({
            key:'id_civico_principale',
            new:opt.id_civico_principale,
            old:itemRes.id_civico_principale
          });

        if (opt.codArcoIsChanged)
        {
          change.push({
            key:'cod_arco',
            new:opt.cod_arco,
            old:itemRes.cod_arco
          });

          change.push({
            key:'cod_via',
            new:opt.cod_via,
            old:itemRes.cod_via
          });

          change.push({
            key:'proiezione_x',
            new:itemRes.npx,
            old:itemRes.opx
          });

          change.push({
            key:'proiezione_y',
            new:itemRes.npy,
            old:itemRes.opy
          });
        }

        var logOpt = {
          object: [{
            user_id: opt.sysuser_id,
            entity: "civico",
            entity_id: itemRes.id,
            operation: opt.operation || "Rinumerazione Civico",
            change: change
          }]
        };

        self.entityHolder.getEntity("grafoLog").bulkInsert(
          logOpt,
          function(lErr,lRes){}
        );
      }
    }
  });
}

// method not used because extreme numbers are valorized with sql view
function recalculateExtremeNumbers(opt,callback)
{
  // retrieve arco for given civico

  /*
   * Query to execute:
   *
   * SELECT cod_arco FROM grafo.civico WHERE id = <idCivico>
   *
   */

  var qOpt = {
    transName: opt.transName,
    fields: [
      {name: "cod_arco"}
    ],
    from: [
      {schema:"grafo", name:"civico", type:self.crudUtils.TABLE}
    ],
    where:[
      {
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: "id",
        operator: self.crudUtils.EQ,
        rightSide: "$1"
      }
    ]
  };

  self.crud.select(qOpt,[{value:opt.idCivico}], function(errA,resA)
  {
    if (errA || !resA.result || resA.result.length == 0)
    {
      var msg = "Error on retrieve arco for civico " + opt.idCivico;

      var logMsg = msg + (errA ? ": " + errA.message : "");

      self.log.error(self.moduleName + " - " + logMsg);

      return callback({message:msg}, null);
    }
    else
    {

      /*
       * Query to execute:
       *
       * SELECT numero,
       *        array_agg(esponente ORDER BY esponente ASC) AS esponente
       * FROM grafo.civico
       * WHERE cod_arco = <cod_arco>
       * AND data_fine IS NULL
       * GROUP BY numero
       * ORDER BY numero ASC
       *
       */

      var qString =
        "SELECT numero,"+
        "array_agg(esponente ORDER BY esponente ASC) AS esponente " +
        "FROM grafo.civico "+
        "WHERE cod_arco = " + resA.result[0].cod_arco +
        " AND data_fine IS NULL " +
        "GROUP BY numero " +
        "ORDER BY numero ASC";


      self.crud.select({queryString:qString},[],function(err,res)
      {
        if (err || !res.result || res.result.length == 0)
        {
          var msg = "Error on retrieve data on arco " + opt.idArco;

          var logMsg = msg + (err ? ": " + err.message : "");

          self.log.error(self.moduleName + " - " + logMsg);

          return callback({message:msg}, null);
        }
        else
        {
          var civMinP = Infinity,
              civMinD = Infinity,
              civMaxP = 0,
              civMaxD = 0;

          var espMinP = null,
              espMaxP = null,
              espMinD = null,
              espMaxD = null;

          // cycle result to find extreme
          for (var idx=0; idx<res.result.length; idx++)
          {
            var item = res.result[idx];

            switch(item.numero % 2)
            {
              // even number
              case 0:
                if (item.numero < civMinP)
                {
                  civMinP = item.numero;
                  expMinP = null;

                  for (var jdx=0; jdx<item.esponente.length; jdx++)
                  {
                    if (item.esponente[jdx] != null)
                    {
                      espMinP = item.esponente[jdx];
                      break;
                    }
                  }
                }

                if (item.numero > civMaxP)
                {
                  civMaxP = item.numero;
                  espMaxP = null;

                  for (var jdx=0; jdx<item.esponente.length; jdx++)
                  {
                    if (item.esponente[jdx] != null)
                    {
                      espMaxP = item.esponente[jdx];
                      break;
                    }
                  }
                }
                break;

              // odd number
              case 1:
                if (item.numero < civMinD)
                {
                  civMinD = item.numero;
                  espMinD = null;

                  for (var jdx=0; jdx<item.esponente.length; jdx++)
                  {
                    if (item.esponente[jdx] != null)
                    {
                      espMinD = item.esponente[jdx];
                      break;
                    }
                  }
                }

                if (item.numero > civMaxD)
                {
                  civMaxD = item.numero;
                  espMaxD = null;

                  for (var jdx=0; jdx<item.esponente.length; jdx++)
                  {
                    if (item.esponente[jdx] != null)
                    {
                      espMaxD = item.esponente[jdx];
                      break;
                    }
                  }
                }
                break;
            }
          }


          // update arco
          qOpt = {
            transName: opt.transName,
            table: {schema:"grafo", name:"arco"},
            fields:[
              {name:"civiminp"},
              {name:"civimind"},
              {name:"civimaxp"},
              {name:"civimaxd"},
              {name:"espominp"},
              {name:"espomind"},
              {name:"espomaxp"},
              {name:"espomaxd"}
            ],
            where: [{
              typeCond: self.crudUtils.SIMPLE_COND,
              leftSide: "cod_arco",
              operator: self.crudUtils.EQ,
              rightSide: resA.result[0].cod_arco
            }]
          };

          var qVal = [
            {value: civMinP},
            {value: civMinD},
            {value: civMaxP},
            {value: civMaxD},
            {value: espMinP},
            {value: espMinD},
            {value: espMaxP},
            {value: espMaxD}
          ];

          self.crud.update(qOpt, qVal, function(errU, resU)
          {
            if (errU || !resU.result)
            {
              var msg = "Error on update extreme numbers on arco " + opt.idArco;

              var logMsg = msg + (errU ? ": " + errU.message : "");

              self.log.error(self.moduleName + " - " + logMsg);

              return callback({message:msg}, null);
            }
            else
            {
              return callback(null, resU);
            }
          });
        }
      });
    }
  })

}

/*
 * method to log operation on grafo.civico_trac table
 *
 * we have to log:
 *
 * 1. insert civico
 *    we have to insert 1 row into grafo.civico_trac (tipoOp = INC),
 *    unless it has id_mot_inserimento that belongs to idMotInserimentoToSkip array
 * 2. delete civico
 *    we have to insert 1 row into grafo.civico_trac (tipoOp = CC),
 *    (unless it has id_mot_cessazione that belongs to idMotCessazioneToSkip array)
 * 3. renumber civico
 *    we have to insert 2 rows into grafo.civico_trac:
 *    tipoOp = SC for new civico and tipoOp = CC for old civico
 *    (unless it has id_mot_cessazione that belongs to idMotCessazioneToSkip array and
 *    id_mot_inserimento that belongs to idMotInserimentoToSkip array)
 */
function logOnCivicoTrac(tipoOp, opt, callback)
{
  /*
   * preliminary tasks:
   *
   * - find localita and circoscrizione for given civico
   * - find attributes for given civico (if tipoOp = CC or SC)
   *
   */

  var x                  = null;
  var y                  = null;
  var cap                = null;
  var numero             = null;
  var esponente          = null;
  var cod_via            = null;
  var cod_arco           = null;
  var principale         = null;
  var provvisorio        = null;
  var serv_rsu           = null;
  var prev_civico        = null;
  var data_ini           = null;
  var data_fine          = null;
  var id_mot_cessazione  = null;
  var id_mot_inserimento = null;
  var id_localita        = null;
  var id_circoscrizione  = null;

  /*
   * Query to execute for localita and circoscrizione:
   * (id_tipo 1 is for localita; 3 is for circoscrizione)
   *
   * SELECT cz.id_zona, z.id_tipo, z.valore
   * FROM grafo.civico_zona cz
   * LEFT JOIN grafo.zona z ON cz.id_zona = z.id
   * WHERE cz.id_civico = <id_civ>
   * AND z.id_tipo IN (1,3)
   *
   */

  var aPar = [];
  var lcVal = [];

  lcVal.push({value: opt.id});

  // prepare value parameters array for IN condition
  aPar.push("$2");
  lcVal.push({value:self.idTipoZonaLocalita});

  aPar.push("$3");
  lcVal.push({value:self.idTipoZonaCircoscrizione});

  var lcOpt = {
    transName: opt.transName,
    fields:[
      {name:'id_zona', aliasT:'cz'},
      {name:'id_tipo', aliasT:'z'},
      {name:'valore',  aliasT:'z'}
    ],
    from:[
      {schema:'grafo', name:'civico_zona', alias:'cz', type:self.crudUtils.TABLE}
    ],
    join:[
      {
        type: self.crudUtils.TABLE,
        join: self.crudUtils.LEFT,
        schema: 'grafo',
        tableName: 'zona',
        alias: 'z',
        cond:
         [
           {
             typeCond: self.crudUtils.SIMPLE_COND,
             leftSide: 'id_zona',
             leftAlias: 'cz',
             operator: self.crudUtils.EQ,
             rightSide: 'id',
             rightAlias: 'z'
           }
         ]
      }
    ],
    where:[
      {
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: 'id_civico',
        leftAlias: 'cz',
        operator: self.crudUtils.EQ,
        rightSide: '$1',
        nextCond: self.crudUtils.AND
      },
      {
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: 'id_tipo',
        leftAlias: 'z',
        operator: self.crudUtils.IN,
        rightSide: aPar.join()
      }
    ]
  };

  /*
   * Query to execute for civico attributes
   *
   * SELECT numero, esponente, cap, x, y, cod_arco, cod_via, principale,
   *        provvisorio, serv_rsu, prev_civico, data_ini, data_fine,
   *        id_mot_cessazione, id_mot_inserimento
   * FROM grafo.civico
   * WHERE id = <id_civico>
   *
   */

  var ciOpt = {
    transName: opt.transName,
    fields:[
      {name:'numero'},
      {name:'esponente'},
      {name:'cap'},
      {name:'x'},
      {name:'y'},
      {name:'cod_arco'},
      {name:'cod_via'},
      {name:'principale'},
      {name:'provvisorio'},
      {name:'serv_rsu'},
      {name:'prev_civico'},
      {name:'data_ini'},
      {name:'data_fine'},
      {name:'id_mot_cessazione'},
      {name:'id_mot_inserimento'}
    ],
    fieldType: {
      data_ini: self.crudUtils.TIMESTAMP,
      data_fine: self.crudUtils.TIMESTAMP
    },
    from:[
      {schema:'grafo', name:'civico', type:self.crudUtils.TABLE}
    ],
    where:[
      {
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: 'id',
        operator: self.crudUtils.EQ,
        rightSide: '$1'
      }
    ]
  };

  var ciVal = [{value:opt.id}];

  // define tasks object
  var tasks = {
    selLC: function(cb) {self.crud.select(lcOpt,lcVal,cb);},
    selCI: function(cb) {self.crud.select(ciOpt,ciVal,cb);}
  };

  // execute preliminary tasks
  async.parallelLimit(tasks, 1, function(errT,resT)
  {
    if (errT)
    {
      callback(errT,null);
    }
    else
    {
      // read id_localita and id_circoscrizione
      if (tasks.selLC)
      {
        for (var idx=0; idx<resT.selLC.result.length; idx++)
        {
          var item = resT.selLC.result[idx];

          switch (item.id_tipo)
          {
            case self.idTipoZonaLocalita:
              id_localita = item.id_zona;
              break;

            case self.idTipoZonaCircoscrizione:
              id_circoscrizione = item.id_zona;
              break;

            default:
              self.log.error(self.moduleName + " - Error: id_tipo " +
                item.id_tipo + " not managed");
          };
        }
      }

      // read civico attributes
      if (tasks.selCI)
      {
        var item = resT.selCI.result[0];

        x                  = item.x;
        y                  = item.y;
        cap                = item.cap;
        numero             = item.numero;
        esponente          = item.esponente;
        cod_via            = item.cod_via;
        cod_arco           = item.cod_arco;
        principale         = item.principale;
        provvisorio        = item.provvisorio;
        serv_rsu           = item.serv_rsu;
        prev_civico        = item.prev_civico;
        data_ini           = item.data_ini;
        data_fine          = item.data_fine;
        id_mot_cessazione  = item.id_mot_cessazione;
        id_mot_inserimento = item.id_mot_inserimento;
      }

      // execute insert

      /*
       * Query to execute:
       *
       * INSERT INTO grafo.civico_trac
       *             (id_user, tipo_op, id_civico, cod_arco, cod_via, numero,
       *              esponente, cap, x, y, principale, provvisorio, serv_rsu,
       *              id_mot_inserimento, id_mot_cessazione, id_circoscrizione,
       *              id_localita, data_ini, data_fine, prev_civico)
       * VALUES ....
       * RETURNING id
       */

      qOpt = {
        transName: opt.transName,
        table: {schema:'grafo', name:'civico_trac'},
        fields:[],
        returning:[{name:'id'}]
      };

      qVal = [];

      // add mandatory (or certainly valued) fields
      qOpt.fields.push({name:'id_user'});
      qVal.push({value:opt.userId});

      qOpt.fields.push({name:'tipo_op'});
      qVal.push({value:tipoOp});

      qOpt.fields.push({name:'id_civico'});
      qVal.push({value:opt.id});

      qOpt.fields.push({name:'id_circoscrizione'});
      qVal.push({value:id_circoscrizione});

      qOpt.fields.push({name:'id_localita'});
      qVal.push({value:id_localita});

      qOpt.fields.push({name:'x'});
      qVal.push({value:x});

      qOpt.fields.push({name:'y'});
      qVal.push({value:y});

      qOpt.fields.push({name:'numero'});
      qVal.push({value:numero});

      qOpt.fields.push({name:'cod_arco'});
      qVal.push({value:cod_arco});

      qOpt.fields.push({name:'cod_via'});
      qVal.push({value:cod_via});

      // add not certainly valued fields
      if (esponente)
      {
        qOpt.fields.push({name:'esponente'});
        qVal.push({value:esponente});
      }

      if (cap)
      {
        qOpt.fields.push({name:'cap'});
        qVal.push({value:cap});
      }

      if (principale != null)
      {
        qOpt.fields.push({name:'principale'});
        qVal.push({value:principale});
      }

      if (provvisorio != null)
      {
        qOpt.fields.push({name:'provvisorio'});
        qVal.push({value:provvisorio});
      }

      if (serv_rsu != null)
      {
        qOpt.fields.push({name:'serv_rsu'});
        qVal.push({value:serv_rsu});
      }

      if (id_mot_inserimento)
      {
        qOpt.fields.push({name:'id_mot_inserimento'});
        qVal.push({value:id_mot_inserimento});
      }

      if (id_mot_cessazione)
      {
        qOpt.fields.push({name:'id_mot_cessazione'});
        qVal.push({value:id_mot_cessazione});
      }

      if (prev_civico)
      {
        qOpt.fields.push({name:'prev_civico'});
        qVal.push({value:prev_civico});
      }

      if (data_ini)
      {
        qOpt.fields.push({name:'data_ini'});
        qVal.push({value:data_ini, type:self.crudUtils.TIMESTAMP});
      }

      if (data_fine)
      {
        qOpt.fields.push({name:'data_fine'});
        qVal.push({value:data_fine, type:self.crudUtils.TIMESTAMP});
      }

      // execute insert
      self.crud.insert(qOpt,qVal,function(err,res)
      {
        if (err || !res.result)
          callback(err, null);
        else
          callback(null, res);
      });

    }
  });

}
