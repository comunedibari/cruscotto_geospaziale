/*
 *    Date: 2018 10 10
 * Project: Nodas - EntityManager
 *
 * Copyright 2018 SIT srl
 */

var entTemp = require("./grafoLogger").grafoLogger;
var async = require("async");
var util = require("util");
var self = {};

var via = function()
{
  via.super_.call(this);

  this.moduleName = "Entity via";
  this.entityName = "via";
  this.schemaName = "grafo";
  this.tableName = "via";

  this.fieldTypeObj = {
    data_ini: this.crudUtils.TIMESTAMP,
    data_fine: this.crudUtils.TIMESTAMP,
    data_delib: this.crudUtils.TIMESTAMP,
    data_verbale: this.crudUtils.TIMESTAMP,
    data_inserimento: this.crudUtils.TIMESTAMP
  };

  this.masterFieldObj = [
    {name: "cod_via"},
    {name: "id_tipo"},
    {name: "localita"},
    {name: "municipio"},
    {name: "localita_val"},
    {name: "municipio_val"},
    {name: "data_fine"},
    {name: "denom_pura"},
    {name: "denominazione"},
    {name: "extent"},
    {name: "archi"}
  ];

  this.entityId = "cod_via";
  this.entityIdType = this.crudUtils.INTEGER;

  /*
   * Variables to manage the log into grafo.via_trac table
   */

  // array of arco attributes whose modification involves writing into via_trac table
  this.listAttributesToLog  = [
    "id_tipo",
    "denominazione",
    "denom_pura",
    "data_ini",
    "data_fine",
    "id_mot_cessazione"
  ];

}

/*
 * Inheritance
 */
util.inherits(via,entTemp);

via.prototype.init = function(opt)
{
  self = this;
  via.super_.prototype.init.call(self,opt);
}

via.prototype.count = function(opt,callback)
{
  opt.tableName = "view_via";
  via.super_.prototype.count.call(self,opt,callback);
}

via.prototype.master = function(opt,callback)
{
  opt.tableName = "view_via";

  via.super_.prototype.master.call(self,opt,function(err,res)
  {
    if (res && res.result)
    {
      for (var j = 0;j < res.result.length;j++)
      {
        var obj = res.result[j];
        obj.extent = self.funcUtils.bboxToArray(obj.extent);
      }
    }

    callback(err,res);
  });
}

via.prototype.detail = function(opt,callback)
{
  opt.tableName = "view_via";

  via.super_.prototype.detail.call(self,opt,function(err,res)
  {
    if (err || !res.result)
    {
      callback(err,res);
      return;
    }

    res.result.extent = self.funcUtils.bboxToArray(res.result.extent);

    /*
     * Get valid archi for given id
     */
    var arcoEnt = self.entityHolder.getEntity("arco");
    var arcoOpt = {
      sysuser_id: opt.sysuser_id,
      object: {
        filter: {
          groupOp: "AND",
          groups: [{
            groupOp:"OR",
            rules:["data_fine|IS|null","data_fine|GT|"+new Date().getTime()],
            groups:[]
          }],
          rules: ["cod_via|EQ|"+opt.id]
        }
      }
    };

    arcoEnt.master(arcoOpt,function(aErr,aRes)
    {
      if (aRes && aRes.result)
        res.result.archi = aRes.result;

      callback(err,res);
    });

    //callback(err,res);
  });
}

via.prototype.insert = function(opt,callback)
{
  var trans = {
    fake: opt.transName != null,
    name: opt.transName || "InsVia_" + new Date().getTime()
  };

  /* Create transaction */
  beginTransaction(trans, function(bgErr)
  {
    if (bgErr)
    {
      callback(bgErr,null);
      return;
    }

    /* Insert via */
    opt.transName = trans.name;
    opt.tableName = "via";

    via.super_.prototype.insert.call(self,opt,function(iErr,iRes)
    {
      if (iErr)
      {
        rollbackTransaction(trans,function(e){callback(iErr,null);});
        return;
      }
      else
      {
        // if noLog, we don't write record into via_trac
        // (....)
        if (opt.noLog)
          commitTransaction(trans,function(e){callback(e,e ? null : iRes);});
        else
        {
          // log into via_trac table
          var logOpt = {
            transName: trans.name,
            id: iRes.result.cod_via,
            userId: opt.sysuser_id
          };

          logOnViaTrac("INV", logOpt, function(errLog, resLog)
          {
            if (errLog)
              rollbackTransaction(trans,function(e){callback(errLog,null);});
            else
              commitTransaction(trans,function(e){callback(e,e ? null : iRes);});
          });
        }
      }
    });
  });
}

via.prototype.update = function(opt,callback)
{
  checkValidArcoOnVia(opt,function(errD,resD)
  {
    if(errD)
    {
      return callback(errD,null);
    }

    var trans = {
      fake: opt.transName != null,
      name: opt.transName || "UpdVia_" + new Date().getTime()
    };

    /* Create transaction */
    beginTransaction(trans, function(bgErr)
    {
      if (bgErr)
      {
        callback(bgErr,null);
        return;
      }

      /* Update via */
      opt.transName = trans.name;
      opt.tableName = "via";

      // this function, if id_tipo, denominazione and denom_pura attributes are updated,
      // returns the old values
      getOldViaAttributes(opt, function(errOld, resOld)
      {
        // update via
        via.super_.prototype.update.call(self,opt,function(uErr,uRes)
        {
          if (uErr || !uRes.result)
          {
            rollbackTransaction(trans,function(e){callback(uErr,null);});
            return;
          }
          else
          {
            var thereAreAttr = false;

            // check if there are attributes whose modification involves recording into via_trac
            for (var key in opt.object)
            {
              if (self.listAttributesToLog.indexOf(key) > 0)
              {
                thereAreAttr = true;
                break;
              }
            }

            // if noLog or there aren't attributes we don't write record into via_trac
            if (opt.noLog || !thereAreAttr)
              commitTransaction(trans,function(e){callback(e,e ? null : uRes);});
            else
            {
              // log into via_trac table
              var logOpt = {
                transName: trans.name,
                id: opt.id,
                userId: opt.sysuser_id
              };

              // write retrieved value into opt object
              if (resOld && resOld.result && resOld.result.length > 0)
              {
                logOpt.oldValue = resOld.result[0];
              }

              var code = (opt.object.data_fine && opt.object.id_mot_cessazione) ? "CV" : "MV";

              logOnViaTrac(code, logOpt, function(errLog, resLog)
              {
                if (errLog)
                  rollbackTransaction(trans,function(e){callback(errLog,null);});
                else
                  commitTransaction(trans,function(e){callback(e,e ? null : uRes);});
              });
            }
          }
        });

      });

    });

  });

}

/*
 * New methods
 */

// return only valid via (with data_fine != null)
via.prototype.masterActive = function(opt,callback)
{
  opt.tableName = "view_via";

  // add data_fine != null filter to existing filter
  // or add it to master option
  if (opt.object.filter)
  {
    opt.object.filter.rules.push("data_fine|IS|null");
    opt.object.filter.groupOp = "AND";
  }
  else
  {
    opt.object.filter = {rules:["data_fine|IS|null"], groups:[], groupOp:""};
  }

  via.super_.prototype.master.call(self,opt,function(err,res)
  {
    if (res && res.result)
    {
      for (var j = 0;j < res.result.length;j++)
      {
        var obj = res.result[j];
        obj.extent = self.funcUtils.bboxToArray(obj.extent);
      }
    }

    callback(err,res);
  });
}

via.prototype.dictionaries = function(opt,callback)
{
  var tpEnt = self.entityHolder.getEntity("viaTipo");
  var tnEnt = self.entityHolder.getEntity("viaTipoNumero");
  var mcEnt = self.entityHolder.getEntity("viaMotCessazione");
  var clEnt = self.entityHolder.getEntity("viaClassificazione");

  if (!tpEnt || !tnEnt || !mcEnt || !clEnt)
  {
    callback({message:"Cannot retrieve dictionary entities"});
    return;
  }

  /* Prepare tasks */
  var masOpt = {sysuser_id:opt.sysuser_id, object:{ord:"name|ASC"}};

  var tasks = {
    tp: function(cb) {tpEnt.master(masOpt,cb);},
    tn: function(cb) {tnEnt.master(masOpt,cb);},
    mc: function(cb) {mcEnt.master(masOpt,cb);},
    cl: function(cb) {clEnt.master(masOpt,cb);}
  };

  /* Exec tasks */
  async.parallelLimit(tasks,1,function(err,res)
  {
    var retObj = null;

    if (!err && res)
    {
      retObj = {result: {
        tipo: res.tp.result,
        tipoNumero: res.tn.result,
        motCessazione: res.mc.result,
        classificazione: res.cl.result
      }};
    }

    callback(err,retObj);
  });
}

via.prototype.rename = function(opt,callback)
{
  opt.transName = "via_rename_" + new Date().getTime();
  opt.operation = "Ridenominazione";

  // add this flag to avoid checkValidArcoOnVia on via update
  opt.rename = true;

  /*
   * Assign object attributes (insert/update)
   * Proxy sysuser_id attributes to insert it into via_trac table
   */
  var insOpt = {
    transName: opt.transName,
    operation: "Ridenominazione",
    sysuser_id: opt.sysuser_id,
    object: {prev_via: opt.id}
  };

  // remove attributes with new_ prefix and put them into insOp object before to execute the insert
  for (var key in opt.object)
  {
    if (key.startsWith("new_"))
    {
      insOpt.object[key.substr(4)] = opt.object[key];
      delete opt.object[key];
    }
  }

  /*
   * Begin transaction
   */
  self.crud.beginTransaction(opt.transName,function(btErr)
  {
    if (btErr)
    {
      callback(btErr,null);
      return;
    }

    /*
     * Insert new via
     */
    self.insert(insOpt,function(iErr,iRes)
    {
      if (iErr)
      {
        self.crud.rollbackTransaction(opt.transName,function(e)
        {
          callback(iErr,null);
        });
      }
      else
      {
        /*
         * Prepare update tasks (on via and arco)
         */
        var upVal = [{value:iRes.result.cod_via},{value:opt.id}];
        var auOpt = {
          transName: opt.transName,
          fields: [{name:"cod_via"}],
          table: {schema:"grafo", name:"arco"},
          where: [{
            typeCond: self.crudUtils.SIMPLE_COND,
            leftSide: "cod_via",
            operator: self.crudUtils.EQ,
            rightSide: "$2"
          }],
          returning: [{name:"cod_arco"}]
        };

        var tasks = {
          update: function(cb) {self.update(opt,cb);},
          upArco: function(cb) {self.crud.update(auOpt,upVal,cb);}
        };

        // look for all civici (valid and that aren't extensions) for given via to renumber them
        var qCivicoArcoOpt = {
          transName: opt.transName,
          fields:[
            {name:"id"},{name:"numero"},{name:"esponente"}
          ],
          from: [{name:"civico", schema:"grafo", type:self.crudUtils.TABLE}],
          where: [{
            typeCond: self.crudUtils.SIMPLE_COND,
            leftSide: "cod_via",
            operator: self.crudUtils.EQ,
            rightSide: opt.id,
            nextCond: self.crudUtils.AND
          },{
            typeCond: self.crudUtils.SIMPLE_COND,
            leftSide: "data_fine",
            operator: self.crudUtils.IS,
            rightSide: null,
            nextCond: self.crudUtils.AND
          },{
            typeCond: self.crudUtils.SIMPLE_COND,
            leftSide: "estensione",
            operator: self.crudUtils.IS,
            rightSide: null
          }]
        };

        // execute query
        self.crud.select(qCivicoArcoOpt,[],function(errC,resC)
        {
          if (errC)
          {
            // manage error
            self.log.error(self.moduleName + " - Error on get all civico of via " +
              opt.id + ": " + errC.message);

            self.crud.rollbackTransaction(opt.transName,function(e)
            {
              callback(errC,null);
            });
          }
          else
          {
            var civicoEnt = self.entityHolder.getEntity("civico");

            // build tasks to renumber founded civici
            for (var idx=0; idx<resC.result.length; idx++)
            {
              // option for civico renumber operation
              var renOpt = {
                sysuser_id: opt.sysuser_id,
                transName: opt.transName,
                object: {
                  data_ini: insOpt.object.data_ini,
                  data_fine: opt.object.data_fine,
                  id_mot_cessazione: 120, // Ridenominazione
                  id_mot_inserimento: 2,  // Rinumerazione
                  next_numero: resC.result[idx].numero,
                  next_esponente: resC.result[idx].esponente,
                  //next_cod_arco: opt.id,
                  next_cod_via: iRes.result.cod_via
                },
                id: resC.result[idx].id,
                operation: "Ridenominazione via",
                noLog: false
              };

              createRenumberCivicoTask(idx, renOpt, tasks, civicoEnt);
            }

            // execute tasks
            async.parallelLimit(tasks,1,function(err,res)
            {
              if (err)
              {
                self.crud.rollbackTransaction(opt.transName,function(e)
                {
                  callback(err,null);
                });
              }
              else
              {
                self.crud.commitTransaction(opt.transName,function(e)
                {
                  callback(e,e ? null : iRes);

                  if (!e && res)
                  {
                    /*
                    * Add log entry for archi/civici (without transaction)
                    */
                    var logOpt = {object: []};

                    if (res.upArco && res.upArco.result)
                    {
                      for (var j = 0;j < res.upArco.result.length;j++)
                      {
                        logOpt.object.push({
                          user_id: opt.sysuser_id,
                          entity: "arco",
                          entity_id: res.upArco.result[j].cod_arco,
                          operation: "Ridenominazione via",
                          change: [{
                            key: "cod_via",
                            new: iRes.result.cod_via,
                            old: opt.id
                          }]
                        });
                      }
                    }

//                     if (res.upCivi && res.upCivi.result)
//                     {
//                       for (var i = 0;i < res.upCivi.result.length;i++)
//                       {
//                         logOpt.object.push({
//                           user_id: opt.sysuser_id,
//                           entity: "civico",
//                           entity_id: res.upCivi.result[i].id,
//                           operation: "Ridenominazione via",
//                           change: [{
//                             key: "cod_via",
//                             new: iRes.result.cod_via,
//                             old: opt.id
//                           }]
//                         });
//                       }
//                     }

                    if (logOpt.object.length)
                    {
                      self.entityHolder.getEntity("grafoLog").bulkInsert(
                        logOpt,
                        function(lErr,lRes){}
                      );
                    }
                  }
                });
              }
            });



          }
        });





        /*
         * Prepare update tasks (on arco and civico)
         */
//         var upVal = [{value:iRes.result.cod_via},{value:opt.id}];
//         var auOpt = {
//           transName: opt.transName,
//           fields: [{name:"cod_via"}],
//           table: {schema:"grafo", name:"arco"},
//           where: [{
//             typeCond: self.crudUtils.SIMPLE_COND,
//             leftSide: "cod_via",
//             operator: self.crudUtils.EQ,
//             rightSide: "$2"
//           }],
//           returning: [{name:"cod_arco"}]
//         };
//         var cuOpt = {
//           transName: opt.transName,
//           fields: [{name:"cod_via"}],
//           table: {schema:"grafo", name:"civico"},
//           where: [{
//             typeCond: self.crudUtils.SIMPLE_COND,
//             leftSide: "cod_via",
//             operator: self.crudUtils.EQ,
//             rightSide: "$2"
//           }],
//           returning: [{name:"id"}]
//         };

        // TODO: we are updating also all civico on that via ->
        // we have to log these operations on civico_trac (with code???)?
//         var tasks = {
//           update: function(cb) {self.update(opt,cb);},
//           upArco: function(cb) {self.crud.update(auOpt,upVal,cb);} //,
//           //upCivi: function(cb) {self.crud.update(cuOpt,upVal,cb);}
//         };

//         /*
//          * Exec update tasks
//          */
//         async.parallelLimit(tasks,1,function(err,res)
//         {
//           if (err)
//           {
//             self.crud.rollbackTransaction(opt.transName,function(e)
//             {
//               callback(err,null);
//             });
//           }
//           else
//           {
//             self.crud.commitTransaction(opt.transName,function(e)
//             {
//               callback(e,e ? null : iRes);
//
//               if (!e && res)
//               {
//                 /*
//                  * Add log entry for archi/civici (without transaction)
//                  */
//                 var logOpt = {object: []};
//
//                 if (res.upArco && res.upArco.result)
//                 {
//                   for (var j = 0;j < res.upArco.result.length;j++)
//                   {
//                     logOpt.object.push({
//                       user_id: opt.sysuser_id,
//                       entity: "arco",
//                       entity_id: res.upArco.result[j].cod_arco,
//                       operation: "Ridenominazione via",
//                       change: [{
//                         key: "cod_via",
//                         new: iRes.result.cod_via,
//                         old: opt.id
//                       }]
//                     });
//                   }
//                 }
//
//                 if (res.upCivi && res.upCivi.result)
//                 {
//                   for (var i = 0;i < res.upCivi.result.length;i++)
//                   {
//                     logOpt.object.push({
//                       user_id: opt.sysuser_id,
//                       entity: "civico",
//                       entity_id: res.upCivi.result[i].id,
//                       operation: "Ridenominazione via",
//                       change: [{
//                         key: "cod_via",
//                         new: iRes.result.cod_via,
//                         old: opt.id
//                       }]
//                     });
//                   }
//                 }
//
//                 if (logOpt.object.length)
//                 {
//                   self.entityHolder.getEntity("grafoLog").bulkInsert(
//                     logOpt,
//                     function(lErr,lRes){}
//                   );
//                 }
//               }
//             });
//           }
//         });
      }
    });
  });
}

/*
 * Export
 */
exports.via = via;

/*
 * Private function
 */
function beginTransaction(opt,callback)
{
  opt.fake ? callback(null) : self.crud.beginTransaction(opt.name,callback);
}

function commitTransaction(opt,callback)
{
  opt.fake ? callback(null) : self.crud.commitTransaction(opt.name,callback);
}

function rollbackTransaction(opt,callback)
{
  opt.fake ? callback(null) : self.crud.rollbackTransaction(opt.name,callback);
}

// build task to renumber a civico on an arco rename
function createRenumberCivicoTask(idx, opt, tasks, civicoEnt)
{
  tasks['civico_'+idx] = function(cb){civicoEnt.renumber(opt, cb);};
}

// check there is valid arco related to given via
function checkValidArcoOnVia(opt,callback)
{
  // in this case we have to skip check on valid arco:
  // - if update not is a via suspension
  // - if we have a rename of via
  if ((!opt.object.data_fine && !opt.object.id_mot_cessazione) ||
       opt.rename)
    return callback(null,null);

  var qOpt = {
    fields: [{name:"cod_arco"}],
    from:[
      {schema:'grafo', name:'view_arco', type:self.crudUtils.TABLE}
    ],
    where:[
      {
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: 'cod_via',
        operator: self.crudUtils.EQ,
        rightSide: '$1',
        nextCond: self.crudUtils.AND
      },
      {
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: 'is_valid_now',
        operator: self.crudUtils.EQ,
        rightSide: '$2'
      }
    ]
  };

  var qVal = [
    {value: opt.id},
    {value: true}
  ];

  self.crud.select(qOpt, qVal, function(errS,resS)
  {
    if (errS || !resS)
    {
      var msg = " Error on retrieve arco related to cod_via " + opt.id;

      var logMsg = msg + (errS ? ": " + errS.message : "");

      self.log.error(self.moduleName + " - " + logMsg);

      callback({message:msg}, null);
    }
    else
    {
      if (resS.result.length > 0)
      {
        self.log.error(self.moduleName + " - there are valid arco related to given cod_via");
        callback({message:"VALID_ARCO"},resS);
      }
      else
      {
        callback(null,null);
      }
    }
  });
}

// retrieve old value of via attributes on MV operation
// (id_tipo, denominazione and denom_pura attributes are updated)
function getOldViaAttributes(opt, callback)
{
  if (opt.object.data_fine && opt.object.id_mot_cessazione)
  {
    callback(null,null);
  }
  else
  {
    var qOpt = {
      transName: opt.transName,
      fields:[
        {name:'id_tipo'},
        {name:'denominazione'},
        {name:'denom_pura'}
      ],
      from:[
        {schema:'grafo', name:'via', type:self.crudUtils.TABLE}
      ],
      where:[
        {
          typeCond: self.crudUtils.SIMPLE_COND,
          leftSide: 'cod_via',
          operator: self.crudUtils.EQ,
          rightSide: '$1'
        }
      ]
    };

    self.crud.select(qOpt, [{value:opt.id}], function(errS, resS)
    {
      if (errS)
        self.log.error(self.moduleName + " - Error on retrieve old via attributes: " + err.message);

      callback(errS, resS);
    });
  }

}
/*
 * method to log operation on grafo.via_trac table
 *
 * we have to log:
 *
 * 1. insert via
 *    we have to insert 1 row into grafo.via_trac (tipoOp = INV)
 * 2. delete via
 *    we have to insert 1 row into grafo.via_trac (tipoOp = CV)
 * 3. modify via
 *    we have to insert 1 row into grafo.via_trac (tipoOp = MV)
 * 4. rename via
 *    we have to insert 2 rows into grafo.via_trac (tipoOp = INV on new via and tipoOp = CV on old via)
 */
function logOnViaTrac(tipoOp, opt, callback)
{
  /*
   * preliminary tasks:
   *
   * - find attributes for given via (if tipoOp = CV or MV)
   *
   */

  /*
   * Query to execute to get via attributes
   *
   * SELECT id_tipo, denominazione, denom_pura,
   *        prev_via, data_ini, data_fine, id_mot_cessazione
   * FROM grafo.via
   * WHERE cod_via = <cod_via>
   *
   */

  var qOpt = {
    transName: opt.transName,
    fields:[
      {name:'id_tipo'},
      {name:'denominazione'},
      {name:'denom_pura'},
      {name:'prev_via'},
      {name:'data_ini'},
      {name:'data_fine'},
      {name:'id_mot_cessazione'}
    ],
    fieldType:{
      data_ini: self.crudUtils.TIMESTAMP,
      data_fine: self.crudUtils.TIMESTAMP
    },
    from:[
      {schema:'grafo', name:'via', type:self.crudUtils.TABLE}
    ],
    where:[
      {
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: 'cod_via',
        operator: self.crudUtils.EQ,
        rightSide: '$1'
      }
    ]
  };

  var qVal = [{value:opt.id}];

  // Exec query
  self.crud.select(qOpt, qVal, function(errD, resD)
  {
    if (errD || !resD.result || resD.result.length == 0)
    {
      var msg = "Error on retrieve attributes for cod_via " + opt.id;

      var logMsg = msg + (errD ? ": " + errD.message : "");

      self.log.error(self.moduleName + " - " + logMsg);

      callback({message:msg}, null);
    }
    else
    {
      // read selected attributes;
      id_tipo           = resD.result[0].id_tipo;
      denominazione     = resD.result[0].denominazione;
      denom_pura        = resD.result[0].denom_pura;
      id_mot_cessazione = resD.result[0].id_mot_cessazione;
      data_ini          = resD.result[0].data_ini;
      data_fine         = resD.result[0].data_fine;
      prev_via          = resD.result[0].prev_via;

      // execute insert

      /*
       * Query to execute:
       *
       * INSERT INTO grafo.via_trac
       *             (id_user, tipo_op, cod_via, id_tipo, denominazione, denom_pura,
       *              id_mot_cessazione, data_ini, data_fine, prev_via)
       * VALUES ....
       * RETURNING id
       */

      qOpt = {
        transName: opt.transName,
        table: {schema:'grafo', name:'via_trac'},
        fields:[],
        returning:[{name:'id'}]
      };

      qVal = [];

      // add mandatory (or certainly valued) fields
      qOpt.fields.push({name:'id_user'});
      qVal.push({value:opt.userId});

      qOpt.fields.push({name:'tipo_op'});
      qVal.push({value:tipoOp});

      qOpt.fields.push({name:'cod_via'});
      qVal.push({value:opt.id});

      qOpt.fields.push({name:'id_tipo'});
      qVal.push({value:id_tipo});

      qOpt.fields.push({name:'denominazione'});
      qVal.push({value:denominazione});

      qOpt.fields.push({name:'denom_pura'});
      qVal.push({value:denom_pura});

      // add not certainly valued fields
      if (id_mot_cessazione)
      {
        qOpt.fields.push({name:'id_mot_cessazione'});
        qVal.push({value:id_mot_cessazione});
      }

      if (data_ini)
      {
        qOpt.fields.push({name:'data_ini'});
        qVal.push({value:data_ini, type:self.crudUtils.TIMESTAMP});
      }

      if (data_fine)
      {
        qOpt.fields.push({name:'data_fine'});
        qVal.push({value:data_fine, type:self.crudUtils.TIMESTAMP});
      }

      if (prev_via && !opt.oldValue)
      {
        qOpt.fields.push({name:'prev_via'});
        qVal.push({value:prev_via});
      }

      // if there old values (tipoOp = MV) add them
      if (opt.oldValue)
      {
        qOpt.fields.push({name:'prev_denominazione'});
        qVal.push({value:opt.oldValue.denominazione});

        qOpt.fields.push({name:'prev_denom_pura'});
        qVal.push({value:opt.oldValue.denom_pura});

        // in this case prev_via is current via
        qOpt.fields.push({name:'prev_via'});
        qVal.push({value:opt.id});

      }

      // execute insert
      self.crud.insert(qOpt,qVal,function(err,res)
      {
        if (err || !res.result)
          callback(err, null);
        else
          callback(null, res);
      });

    }
  });
}
