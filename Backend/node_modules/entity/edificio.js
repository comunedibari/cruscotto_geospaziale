/*
 *    Date: 2018 10 24
 * Project: Nodas - EntityManager
 *
 * Copyright 2018 SIT srl
 */

var entTemp = require("./grafoLogger").grafoLogger;
var async = require("async");
var util = require("util");
var self = {};

// macro to manage check of presence of valid civici on edificio to delete
var _EDIFICIO_WITH_VALID_CIVICI = "EDIFICIO_WITH_VALID_CIVICI";

var edificio = function()
{
  edificio.super_.call(this);

  this.moduleName = "Entity edificio";
  this.entityName = "edificio";
  this.schemaName = "grafo";
  this.tableName = "edificio";
  this.tableSrid  = 32633;

  this.fieldTypeObj = {
    data_ini: this.crudUtils.TIMESTAMP,
    data_fine: this.crudUtils.TIMESTAMP,
    data_ri_mappa: this.crudUtils.TIMESTAMP,
    data_ins_mappa: this.crudUtils.TIMESTAMP
  };

  this.masterFieldObj = [
    {name: "id"},
    {name: "id_tipo"},
    {name: "id_stato"},
    {name: "data_fine"},
    {name: "geom", aliasF:"x_min", operator:this.crudUtils.X_MIN},
    {name: "geom", aliasF:"x_max", operator:this.crudUtils.X_MAX},
    {name: "geom", aliasF:"y_min", operator:this.crudUtils.Y_MIN},
    {name: "geom", aliasF:"y_max", operator:this.crudUtils.Y_MAX}
  ];
  this.detailFieldObj = [
    {name: "id"},
    {name: "id_tipo"},
    {name: "id_stato"},
    {name: "data_ini"},
    {name: "data_fine"},
    {name: "id_diff_catasto"},
    {name: "id_mot_cessazione"},
    {name: "id_uso_prevalente"},
    {name: "qualita_uso_prevalente"},
    {name: "anno_costr"},
    {name: "qualita_anno_costr"},
    {name: "cod_comune"},
    {name: "foglio"},
    {name: "numero"},
    {name: "sezione"},
    {name: "denominatore"},
    {name: "edificialita"},
    {name: "denominazione"},
    {name: "ppi_anno"},
    {name: "ppi_numero"},
    {name: "ppi_qualita"},
    {name: "ac_anno"},
    {name: "ac_numero"},
    {name: "data_ins_mappa"},
    {name: "data_ri_mappa"},
    {name: "lnba"},
    {name: "lnba_qualita"},
    {name: "sezione_urbana"},
    {name: "sotterraneo"},
    {name: "geom", aliasF:"x_min", operator:this.crudUtils.X_MIN},
    {name: "geom", aliasF:"x_max", operator:this.crudUtils.X_MAX},
    {name: "geom", aliasF:"y_min", operator:this.crudUtils.Y_MIN},
    {name: "geom", aliasF:"y_max", operator:this.crudUtils.Y_MAX}
  ];

  this.entityId = "id";
  this.entityIdType = this.crudUtils.INTEGER;
}

/*
 * Inheritance
 */
util.inherits(edificio,entTemp);

edificio.prototype.init = function(opt)
{
  self = this;
  edificio.super_.prototype.init.call(self,opt);
}

edificio.prototype.detail = function(opt,callback)
{
  edificio.super_.prototype.detail.call(self,opt,function(err,res)
  {
    if (err || !res.result)
    {
      callback(err,res);
      return;
    }

    /*
     * Get valid civici for given id
     */
    var cvEnt = self.entityHolder.getEntity("civico");
    var cvOpt = {
      sysuser_id: opt.sysuser_id,
      object: {
        filter: {
          groupOp: "AND",
          groups: [{
            groupOp:"OR",
            rules:["data_fine|IS|null","data_fine|GT|"+new Date().getTime()],
            groups:[]
          }],
          rules: ["id_edificio|ANY|"+opt.id]
        }
      }
    };

    cvEnt.master(cvOpt,function(cvErr,cvRes)
    {
      if (cvRes && cvRes.result)
        res.result.civici = cvRes.result;

      callback(err,res);
    });
  });
}

edificio.prototype.insert = function(opt,callback)
{
  var geomGeoJSON = opt.object.geoJSON;

  if (!geomGeoJSON)
  {
    var msg = "Missing geoJSON geometry to insert!";
    self.log.error(self.moduleName + " - " + msg);
    return callback({message:msg},null);
  }

  var strGeom = JSON.stringify(geomGeoJSON);

  var edificioGeom = "ST_SetSRID("+
    "ST_GeomFromGeoJSON('" + strGeom + "')," +
    self.tableSrid +
  ")";

  // the attributes that should not be inserted are removed
  delete opt.object.geoJSON;

  var strListAttrs  = "";
  var strListValues = "";

  var index = 1;
  var qVal = [];

  // cycle on attributes to build dinamically attrs and values list
  Object.keys(opt.object).forEach(function(key)
  {
    strListAttrs += key + ", ";

    strListValues += "$" + index + ", ";

    var valueObj = {value:opt.object[key]};

    if (key == 'data_ini')
      valueObj.type = self.crudUtils.TIMESTAMP;

    qVal.push(valueObj);

    index++;
  });

  strListAttrs  += "geom";
  strListValues += edificioGeom;

  strListAttrs  += ",data_ins_mappa";
//   strListValues += ",'" + new Date(opt.object.data_ini).toCustomString() + "'";
  strListValues += (",$" + index);
  qVal.push({value:new Date(opt.object.data_ini)});

  var qString =
    "INSERT INTO grafo.edificio (" + strListAttrs + ") " +
    "VALUES (" + strListValues + ") " +
    "RETURNING id;";

  self.crud.insert({queryString: qString}, qVal, function(err,res)
  {
    if (err)
    {
      self.log.error(self.moduleName + " - Error on insert new edificio: " + err.message);

      callback(err,null);
    }
    else
    {
      callback(null, res);

      // write into log table
      var change = [];

      // cycle on input data to log their  values
      // (not for geoJSON [extra attributes])
      Object.keys(opt.object).forEach(function(key)
      {
        if (key != 'geoJSON')
        {
          change.push({
            key:key,
            new:opt.object[key]
          });
        }
      });

      var logOpt = {
        object: [{
          user_id: opt.sysuser_id,
          entity: "edificio",
          entity_id: res.result.id,
          operation: "Inserimento edificio",
          change: change
        }]
      };

      self.entityHolder.getEntity("grafoLog").bulkInsert(
        logOpt,
        function(lErr,lRes){}
      );
    }
  });
}

edificio.prototype.update = function(opt,callback)
{
  if (!opt.object.geoJSON)
    edificio.super_.prototype.update.call(self,opt,callback);
  else
  {
    var translateObj = opt.object.translate ? opt.object.translate : null;

    // remove translate properties (extra attributes not necessary)
    delete opt.object.translate;

    var now = new Date().getTime();

    var transName = "update_edificio_" + now;

    /*
     * build geometry to update from received geoJSON as:
     *
     * ST_SetSRID(ST_GeomFromGeoJSON(<geoJSON>),<srid>)
     *
     */

    var qStrU = "UPDATE grafo.edificio AS NEW SET ";
    var qRet  = "RETURNING ";

    // cycle on attributes to build dinamically attrs and values list
    Object.keys(opt.object).forEach(function(key)
    {
      switch(key)
      {
        case 'geoJSON':
          var strGeom = JSON.stringify(opt.object[key]);
          var edificioGeom = "ST_SetSRID("+
            "ST_GeomFromGeoJSON('" + strGeom + "')," +
            self.tableSrid +
          ")";

          qStrU += "geom = ";
          qStrU += edificioGeom + ", ";
          break;

        default:
          qStrU += key + " = ";
          qStrU += opt.object[key] + ", ";
          qRet    += "OLD." + key + ", ";
      }
    });

    // remove last comma
    qStrU = qStrU.substring(0, qStrU.lastIndexOf(","));
    qRet  = qRet.substring(0, qRet.lastIndexOf(","));

    // add FROM
    qStrU += " FROM grafo.edificio AS OLD ";

    // add where condition
    qStrU += "WHERE OLD.id = $1 AND OLD.id = NEW.id ";

    // add returning option
    qStrU += qRet;


    // Begin transaction
    self.crud.beginTransaction(transName, function(btErr)
    {
      if (btErr)
      {
        callback(btErr,null);
        return;
      }

      // select all civico associated with the given edificio
      // and which fall within the building or on its edge
      // (we have to select them first to update edificio geometry)
      // we have to expand edificio geom to select also related civico that are very close

      /*
       * Query to execute:
       *
       * SELECT id,x,y FROM grafo.view_civico
       * WHERE <id_edificio> = ANY(id_edificio)
       * AND is_valid_now = true
       * AND ST_Contains((SELECT ST_Buffer(geom,0.01) FROM grafo.edificio WHERE id = <id_edificio>), geom) = true
       *
       */

       var qStrS =
         "SELECT id,x,y FROM grafo.view_civico " +
         "WHERE $1 = ANY(id_edificio) " +
         "AND is_valid_now = true " +
         "AND ST_Contains((SELECT ST_Buffer(geom,0.01) FROM grafo.edificio WHERE id = $1),geom) = true";

      self.crud.select(
        {transName:transName, queryString: qStrS},
        [{value:opt.id}],
        function(err,res)
        {
          if (err)
          {
            self.log.error(self.moduleName +
              " - Error on select all valid civico related to given edificio: " + err.message);

            self.crud.rollbackTransaction(transName,function(e)
            {
              callback(err,null);
            });
          }
          else
          {
            // update edificio (geometry and other attributes)
            self.crud.update(
              {transName:transName, queryString: qStrU},
              [{value:opt.id}],
              function(errU,resU)
              {
                if (errU)
                {
                  self.log.error(self.moduleName + " - Error on update edificio: " + errU.message);

                  //callback(err,null);
                  self.crud.rollbackTransaction(transName,function(e)
                  {
                    callback(errU,null);
                  });
                }
                else
                {
                  // only if transformation is a pure translation
                  // we have to move also related civici
                  // (if previous select return them <=> res.result.length > 0)
                  if (translateObj && translateObj.isTranslation && res.result.length)
                  {
                    var tasks= {};

                    var civicoEnt = self.entityHolder.getEntity("civico");

                    for (var idx=0; idx<res.result.length; idx++)
                    {
                      var civico = res.result[idx];

                      createMoveCivicoTask(idx, civicoEnt, civico, translateObj.deltaX, translateObj.deltaY, transName, opt, tasks);
                    }

                    // Execute tasks
                    async.parallelLimit(tasks,1,function(errT,resT)
                    {
                      if (errT)
                      {
                        // manage tasks error
                        self.log.error(self.moduleName + " - Error: " + errT.message);

                        self.crud.rollbackTransaction(transName,function(e)
                        {
                          callback(errT,null);
                        });
                      }
                      else
                      {
                        self.crud.commitTransaction(transName, function(e)
                        {
                          callback(e,e ? null : resU);
                        });
                      }
                    });
                  }
                  else
                  {
                    self.crud.commitTransaction(transName,function(e)
                    {
                      callback(e,e ? null : resU);
                    });
                  }

                  // write into log table
                  var change = [];

                  // cycle on changed object to log their old and new values
                  // (not for geoJSON [extra attributes])
                  Object.keys(opt.object).forEach(function(key)
                  {
                    if (resU.result[0] && key != 'geoJSON')
                    {
                      change.push({
                        key:key,
                        new:opt.object[key],
                        old:resU.result[0][key]
                      });
                    }
                  });

                  var logOpt = {
                    object: [{
                      user_id: opt.sysuser_id,
                      entity: "edificio",
                      entity_id: opt.id,
                      operation: "Modifica edificio",
                      change: change
                    }]
                  };

                  self.entityHolder.getEntity("grafoLog").bulkInsert(
                    logOpt,
                    function(lErr,lRes){}
                  );
                }
              }
            );
          }
        }
      );
    });

  }

}

/*
 * New methods
 */
edificio.prototype.dictionaries = function(opt,callback)
{
  var e1 = self.entityHolder.getEntity("edificioTipo");
  var e2 = self.entityHolder.getEntity("edificioStato");
  var e3 = self.entityHolder.getEntity("edificioDiffCatasto");
  var e4 = self.entityHolder.getEntity("edificioMotCessazione");
  var e5 = self.entityHolder.getEntity("edificioUsoPrevalente");

  if (!e1 || !e2 || !e3 || !e4 || !e5)
  {
    callback({message:"Cannot retrieve dictionary entities"});
    return;
  }

  /*
   * Prepare tasks
   */
  var masOpt = {sysuser_id:opt.sysuser_id, object:{ord:"name|ASC"}};

  var tasks = {
    tipo: function(cb){e1.master(masOpt,cb);},
    stato: function(cb){e2.master(masOpt,cb);},
    diffCatasto: function(cb){e3.master(masOpt,cb);},
    motCessazione: function(cb){e4.master(masOpt,cb);},
    usoPrevalente: function(cb){e5.master(masOpt,cb);}
  };

  /*
   * Exec tasks
   */
  async.parallelLimit(tasks,1,function(err,res)
  {
    var retObj = null;

    if (!err && res)
    {
      retObj = {result: {}};

      for (var key in res)
        retObj.result[key] = res[key].result;
    }

    callback(err,retObj);
  });
}

// remove edificio
edificio.prototype.remove = function(opt,callback)
{
  /*
   * we have to:
   *
   * 1. check if on given edificio there are valid civico (with data_fine null)
   *
   * 2. if no, delete edificio (update with data_fine), if yes return error
   *
   */

  /*
   * Query to execute
   *
   * SELECT id FROM grafo.civico
   * WHERE <cod_arco> = ANY(id_edificio)
   * AND data_fine IS NULL
   *
   */

  var qOpt = {
    fields:[
      {name:'id'}
    ],
    from:[
      {schema:'grafo', name:'civico', type:self.crudUtils.TABLE}
    ],
    where:[
      {
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: 'id_edificio',
        operator: self.crudUtils.ANY,
        rightSide: '$1',
        nextCond: self.crudUtils.AND
      },
      {
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: 'data_fine',
        operator: self.crudUtils.IS,
        rightSide: null
      }
    ]
  };

  // check if given edificio has valid civici on it
  self.crud.select(qOpt, [{value:opt.id}], function(err, res)
  {
    if (err)
    {
      var msg = "Error on retrieve valid civici on edificio " + opt.id;

      self.log.error(self.moduleName + " - " + msg + ": " +err.message);

      callback({message:msg}, null);
    }
    else if (res && res.result.length > 0)
    {
      self.log.info(self.moduleName + " - edificio " + opt.id +
        " has valid civici on it. It cannot be removed!");

      callback({message:_EDIFICIO_WITH_VALID_CIVICI}, null);
    }
    else
    {
      // set operation to log
      opt.operation = "Rimozione edificio";

      // update edificio (set data_fine)
      edificio.super_.prototype.update.call(self,opt,function(errU,resU)
      {
        if (errU || !resU.result)
        {
          var msg = "Error on remove edificio with id " + opt.id;

          var logMsg = msg + (errU ? ": " + errU.message : "");

          self.log.error(self.moduleName + " - " + logMsg);

          callback({message:msg}, null);
        }
        else
        {
          callback(null, resU);
        }
      });
    }
  });

}

// find cadastral data for edificio given its geom
edificio.prototype.findCadastralData = function(opt,callback)
{
  if (!opt.object.geom)
  {
    var msg = "Missing geometry from request"
    self.log.error(self.moduleName + " - " + msg);
    callback({message:msg},null);
  }

  /*
   * Query to execute:
   * (we have to return only the first result - intersect with higher area)
   *
   * SELECT vcf.gid,vcf.codice_comune,vcf.sezione,vcf.foglio,vcf.numero,
   *        ST_Area(ST_Intersection(vcf.geom, ST_SetSRID(ST_GeomFromGeoJSON(<geom>),32633))) AS area
   * FROM catasto.view_catasto_fabbricati vcf
   * WHERE ST_Intersects(vcf.geom, ST_SetSRID(ST_GeomFromGeoJSON(<geom>),32633)) = true
   * ORDER BY area DESC
   *
   */

  var strGeom = JSON.stringify(opt.object.geom);

  var qStr =
    "SELECT vcf.gid,vcf.codice_comune,vcf.sezione,vcf.foglio,vcf.numero," +
    "ST_Area(ST_Intersection(vcf.geom, ST_SetSRID(ST_GeomFromGeoJSON('" + strGeom + "'),32633))) AS area " +
    "FROM catasto.view_catasto_fabbricati vcf " +
    "WHERE ST_Intersects(vcf.geom, ST_SetSRID(ST_GeomFromGeoJSON('" + strGeom + "'),32633)) = true " +
    "ORDER BY area DESC";

  self.crud.select( {queryString: qStr}, [], function(err,res){
    if (err || !res.result || res.result.length == 0)
    {self.log.info(err);
      var msg = "Error on select cadastral information related to given geometry edificio" +
        (err ? ": " + err.message : "");

      self.log.error(self.moduleName + " - " + msg);

      callback({message:msg},null);
    }
    else
    {
      callback(null, {result:res.result[0]});
    }
  });
}

/*
 * Export
 */
exports.edificio = edificio;

/*
 * Private functions!
 */

// build task to move civico related
function createMoveCivicoTask(idx, civicoEnt, civico, deltaX, deltaY, transName, opt, tasks)
{
  // get geometry data for civico in new position
  var civOpt = {
    sysuser_id: opt.sysuser_id,
    transName: transName,
    object: {
      x: civico.x + deltaX,
      y: civico.y + deltaY
    },
    id: civico.id,
    operation: "Modifica edificio"
  };

  tasks['civico_'+idx] = function(cb){civicoEnt.update(civOpt, cb);};
}
