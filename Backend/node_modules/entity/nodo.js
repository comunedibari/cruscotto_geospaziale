/*
 *    Date: 2018 10 24
 * Project: Nodas - EntityManager
 *
 * Copyright 2018 SIT srl
 */

var entTemp = require("./grafoLogger").grafoLogger;
var async = require("async");
var util = require("util");
var self = {};

var nodo = function()
{
  nodo.super_.call(this);

  this.moduleName = "Entity nodo";
  this.entityName = "nodo";
  this.schemaName = "grafo";
  this.tableName = "nodo";
  this.tableSrid  = 32633;

  this.fieldTypeObj = {
    data_ini: this.crudUtils.TIMESTAMP,
    data_fine: this.crudUtils.TIMESTAMP
  };

  this.masterFieldObj = [
    {name: "id"},
    {name: "id_tipo"},
    {name: "data_fine"},
    {name: "geom", aliasF:"x", operator:this.crudUtils.X_COORD_POINT},
    {name: "geom", aliasF:"y", operator:this.crudUtils.Y_COORD_POINT}
  ];
  this.detailFieldObj = [
    {name: "id"},
    {name: "nota"},
    {name: "id_tipo"},
    {name: "data_ini"},
    {name: "data_fine"},
    {name: "toponomastica"},
    {name: "id_tipo_lim_amm"},
    {name: "geom", aliasF:"x", operator:this.crudUtils.X_COORD_POINT},
    {name: "geom", aliasF:"y", operator:this.crudUtils.Y_COORD_POINT}
  ];

  this.entityId = "id";
  this.entityIdType = this.crudUtils.INTEGER;
}

/*
 * Inheritance
 */
util.inherits(nodo,entTemp);

nodo.prototype.init = function(opt)
{
  self = this;
  nodo.super_.prototype.init.call(self,opt);
}

nodo.prototype.detail = function(opt,callback)
{
  nodo.super_.prototype.detail.call(self,opt,function(err,res)
  {
    if (err || !res || !res.result)
    {
      callback(err,res);
      return;
    }

    /* Get arcs that flow into given node */
    opt.object.idNodo = opt.id;

    nodo.prototype.retrieveArcoInNodo(opt, function(aErr,aRes)
    {
      if (aRes && aRes.result)
        res.result.archi = aRes.result;

      callback(null,res);
    });
  });
}

/*
 * New methods
 */

// retrieve all valid arco that flow into given node
nodo.prototype.retrieveArcoInNodo = function(opt,callback)
{
  if (!opt.object.idNodo)
  {
    var msg = "missing parameter into request!";
    self.log.error(self.moduleName + " - " + msg);
    callback({message:msg}, null)
  }

  /*
   * Query to execute:
   *
   * SELECT DISTINCT a.cod_arco, v.cod_via, v.denominazione AS nome_via
   * FROM grafo.arco a
   * LEFT JOIN grafo.via v ON a.cod_via = v.cod_via
   * WHERE (a.nodo_a = $1 OR a.nodo_da = $1) AND
   *       (a.data_fine IS NULL OR a.data_fine > now)
   *
   */

  var qOpt = {
    fields:[
      {name:"cod_arco", aliasT:"a"},
      {name:"cod_via", aliasT:"v"},
      {name:"denominazione", aliasT:"v", aliasF:"nome_via"}
    ],
    from:[{
      schema:"grafo",name:"arco",alias:"a",type:self.crudUtils.TABLE
    }],
    join:[{
      type:self.crudUtils.TABLE,
      join:self.crudUtils.LEFT,
      schema:"grafo",
      tableName:"via",
      alias:"v",
      cond:[{
        typeCond:self.crudUtils.SIMPLE_COND,
        leftSide:"cod_via",
        leftAlias:"a",
        rightSide:"cod_via",
        rightAlias:"v",
        operator:self.crudUtils.EQ
      }]
    }],
    where:[
      {
        typeCond: self.crudUtils.COMPLEX_COND,
        conds:[{
          typeCond:self.crudUtils.SIMPLE_COND,
          leftSide:"nodo_a",
          leftAlias:"a",
          rightSide:"$1",
          operator:self.crudUtils.EQ,
          nextCond:self.crudUtils.OR
        },{
          typeCond:self.crudUtils.SIMPLE_COND,
          leftSide:"nodo_da",
          leftAlias:"a",
          rightSide:"$1",
          operator:self.crudUtils.EQ
        }],
        nextCond:self.crudUtils.AND
      },
      {
        typeCond:self.crudUtils.COMPLEX_COND,
        conds:[{
          leftSide:"data_fine",
          leftAlias:"a",
          rightSide:null,
          operator:self.crudUtils.IS,
          nextCond:self.crudUtils.OR
        },{
          leftSide:"data_fine",
          leftAlias:"a",
          rightSide:"$2",
          operator:self.crudUtils.GT
        }]
      }
    ]
  };

  var qVal = [
    {value:opt.object.idNodo},
    {value:new Date().getTime(), type:self.crudUtils.TIMESTAMP}
  ];

  self.crud.select(qOpt, qVal, function(err,res)
  {
    if (err)
    {
      self.log.error(self.moduleName +
        " - Error on find arco that flow into node " + opt.object.idNodo + ": " + err.message);

      callback(err, null);
    }
    else
    {
      callback(null,res);
    }
  });
}

// check if given point is valid to break an existing arco (i.e. to be a node)
// (point lies on valid arco and doesn't coincide with any valid node)
// method return a numeric error code:
// 1 -> generic error on query execution
// 2 -> given point doesn't overlap any valid arco
// 3 -> given point overlap a valid node
nodo.prototype.checkBreakValidity = function(opt,callback)
{
  /*
   * Query to execute to check if given point is on existing arco:
   *
   * SELECT cod_arco
   * FROM grafo.arco
   * WHERE ST_DWithin(<geom arco>, (ST_SetSRID(ST_MakePoint(<x>,<y>),<srid>)),0.01)
   * AND data_fine IS null
   *
   */

  var point = "ST_SetSRID("+
    "ST_MakePoint(" + opt.object.x +"," + opt.object.y + ")," + opt.object.srid + 
  ")";

  var qStr =
    "SELECT cod_arco " +
    "FROM grafo.arco " +
    "WHERE ST_DWithin(geom," + point + ",0.01) " +
    "AND data_fine IS null";

  self.crud.select({queryString:qStr},[], function(errA, resA)
  {
    if (errA)
    {
      self.log.error(self.moduleName +
        " - Error on check if given point is on a valid arco: " + errA.message);

      callback({message:1}, null);
    }
    else if (resA.result.length == 0)
    {
      self.log.error(self.moduleName +
        " - given point cannot be a node because doesn't lies on any valid arco");

      callback({message:2}, null);
    }
    else
    {
      /*
       * Given point is on a valid arco
       * Query to execute to check if given point is on existing node:
       *
       * SELECT id
       * FROM grafo.nodo
       * WHERE ST_DWithin(<geom nodo>, (ST_SetSRID(ST_MakePoint(<x>,<y>),<srid>)),0.01)
       * AND data_fine IS null
       *
       */

      qStr =
        "SELECT id " +
        "FROM grafo.nodo " +
        "WHERE ST_DWithin(geom," + point + ",0.01) " +
        "AND data_fine IS null";

      self.crud.select({queryString:qStr},[], function(errN, resN)
      {
        if (errN)
        {
          self.log.error(self.moduleName +
            " - Error on check if given point is on a valid nodo: " + errN.message);

          callback(errN, null);
        }
        else if (resN.result.length > 0)
        {
          self.log.error(self.moduleName +
            " - given point cannot be a node because coincides with node " +
            resN.result[0].id);

          callback(null,{error:3, node:resN.result[0].id});
        }
        else // (resN.result.length == 0)
        {
          // this is valid situation:
          // given point is on a valid arco and doesn't coincide with any valid node
          callback(null, resA);
        }
      });
    }
  });
}

// check if given node is suitable to join the arco that flow into it
// method return a numeric error code:
// 1 -> generic error on query execution
// 2 -> more than 2 arco flow into given node
// 3 -> less than 2 arco flow into given node
// 4 -> 2 arco flow into given node, but they belongs to different via
nodo.prototype.checkMergeValidity = function(opt,callback)
{
  nodo.prototype.retrieveArcoInNodo(opt, function(err,res)
  {
    if (err)
    {
      callback({message:1}, null);
    }
    else if (res.result.length != 2)
    {
      self.log.info(self.moduleName +
        " - Into given node flow into " + res.result.length + "arco");

      var retValue = res.result.length > 2 ? 2 : 3;

      callback({message:retValue}, res);
    }
    else
    {
      var sameVia = true;

      for (var idx=0; idx<res.result.length-1; idx++)
      {
        if (res.result[idx].cod_via != res.result[idx+1].cod_via)
        {
          sameVia = false;
          self.log.info(self.moduleName +
            " - 2 arco flow into given node, but belongs to different via");
          break;
        }
      }

      if (!sameVia)
        callback({message:4}, res);
      else
        callback(null,res);
    }
  });
  
  
//   if (!opt.object.idNodo)
//   {
//     var msg = "missing parameter into request!";
//     self.log.error(self.moduleName + " - " + msg);
//     callback({message:msg}, null)
//   }

  /*
   * Query to execute:
   *
   * SELECT DISTINCT a.cod_arco, v.cod_via
   * FROM grafo.arco a
   * LEFT JOIN grafo.via v ON a.cod_via = v.cod_via
   * WHERE (a.nodo_a = $1 OR a.nodo_da = $1) AND a.data_fine IS NULL
   *
   */

//   var qOpt = {
//     fields:[
//       {name:"cod_arco", aliasT:"a"},
//       {name:"cod_via", aliasT:"v"}
//     ],
//     from:[{
//       schema:"grafo",name:"arco",alias:"a",type:self.crudUtils.TABLE
//     }],
//     join:[{
//       type:self.crudUtils.TABLE,
//       join:self.crudUtils.LEFT,
//       schema:"grafo",
//       tableName:"via",
//       alias:"v",
//       cond:[{
//         typeCond:self.crudUtils.SIMPLE_COND,
//         leftSide:"cod_via",
//         leftAlias:"a",
//         rightSide:"cod_via",
//         rightAlias:"v",
//         operator:self.crudUtils.EQ
//       }]
//     }],
//     where:[{
//       typeCond: self.crudUtils.COMPLEX_COND,
//       conds:[{
//         typeCond:self.crudUtils.SIMPLE_COND,
//         leftSide:"nodo_a",
//         leftAlias:"a",
//         rightSide:"$1",
//         operator:self.crudUtils.EQ,
//         nextCond:self.crudUtils.OR
//       },{
//         typeCond:self.crudUtils.SIMPLE_COND,
//         leftSide:"nodo_da",
//         leftAlias:"a",
//         rightSide:"$1",
//         operator:self.crudUtils.EQ
//       }],
//       nextCond:self.crudUtils.AND
//     },{
//       typeCond:self.crudUtils.SIMPLE_COND,
//       leftSide:"data_fine",
//       leftAlias:"a",
//       rightSide:null,
//       operator:self.crudUtils.IS
//     }]
//   };
// 
//   self.crud.select(qOpt, [{value:opt.object.idNodo}], function(err,res)
//   {
//     if (err)
//     {
//       self.log.error(self.moduleName +
//         " - Error on check if given node can merge arco flow into it: " + err.message);
// 
//       callback({message:1}, null);
//     }
//     else if (res.result.length != 2)
//     {
//       self.log.info(self.moduleName +
//         " - Into given node flow into " + res.result.length + "arco");
// 
//       var retValue = res.result.length > 2 ? 2 : 3;
// 
//       callback({message:retValue}, res);
//     }
//     else
//     {
//       var sameVia = true;
// 
//       for (var idx=0; idx<res.result.length-1; idx++)
//       {
//         if (res.result[idx].cod_via != res.result[idx+1].cod_via)
//         {
//           sameVia = false;
//           self.log.info(self.moduleName +
//             " - 2 arco flow into given node, but belongs to different via");
//           break;
//         }
//       }
// 
//       if (!sameVia)
//         callback({message:4}, res);
//       else
//         callback(null,res);
//     }
//   });
}

// move given nodo and linked archi
nodo.prototype.move = function(opt, callback)
{
  /*
   * we have to:
   *
   * 1. update given node with new coordinates
   * 2. update linked archi with new coordinates and length
   * 3. if selected node is a terminal node (only one arco flow into it)
   *    and overlap another node, we have to remove selected nodo
   *    and replace with the other one
   */

  var now = new Date().getTime();

  var tasks = {};

  var transName = "move_nodo_" + now;

  // Begin transaction
  self.crud.beginTransaction(transName, function(btErr)
  {
    if (btErr)
    {
      callback(btErr,null);
      return;
    }

    var nodoGeom =
      "ST_SetSRID("+
        "ST_MakePoint(" + opt.object.nodo.coords[0] + ", " +
                          opt.object.nodo.coords[1] + "), " +
        self.tableSrid +
      ")";

    var qString =
      "UPDATE grafo.nodo AS NEW SET geom = " + nodoGeom;

    var qRet = "RETURNING ";

    var qVal = [
      {value:opt.object.nodo.id}
    ];

    if(opt.object.mode == "OVERLAP_AND_RESHAPE")
    {
      // in this case we have also to delete this nodo
      qString += ", data_fine = $2 ";

      qRet += "OLD.data_fine, ";

      qVal.push({value:now, type:self.crudUtils.TIMESTAMP});
    }

    // add FROM
    qString += " FROM grafo.nodo AS OLD ";

    // add where condition
    qString += "WHERE OLD.id = $1 AND OLD.id = NEW.id ";

    qString += qRet + "OLD.id;";

    var nodoOpt = {
      sysuser_id:opt.sysuser_id,
      transName: transName,
      queryString: qString
    };

    tasks.nodo = function(cb){self.crud.update(nodoOpt, qVal, cb);};

    var arcoOpt = [];

    // cycle on archi that flow into given node
    for (var idx=0; idx<opt.object.archi.length; idx++)
    {
      var arco = opt.object.archi[idx];

      // if mode is OVERLAP_AND_RESHAPE we have a terminal node (only one arco)
      // that overlap another node; we have to replace terminal node with this one
      var overlap = (opt.object.mode == "OVERLAP_AND_RESHAPE") ?
        opt.object.overlapNodes : null;
      var nodo    = (opt.object.mode == "OVERLAP_AND_RESHAPE") ?
        opt.object.nodo : null;

      createArcoTask(idx, arco, overlap, nodo, tasks, transName, opt);
    }

    // execute tasks to update nodo position and linked archi
    async.parallelLimit(tasks,1,function(errT,resT)
    {
      if (errT)
      {
        // manage tasks error
        self.log.error(self.moduleName + " - Error: " + errT.message);

        self.crud.rollbackTransaction(transName,function(e)
        {
          callback(errT,null);
        });
      }
      else
      {
        self.crud.commitTransaction(transName, function(e)
        {
          var ret = {
            nodo:resT.nodo.result[0].id
          };

          callback(e,e ? null : {result:ret});

          // write into log table query on node
          var change = [];

          if(opt.object.mode == "OVERLAP_AND_RESHAPE")
          {
            change.push({
              key:'data_fine',
              new:now,
              old:resT.nodo.result[0].data_fine
            });
          }

          var logOpt = {
            object: [{
              user_id: opt.sysuser_id,
              entity: "nodo",
              entity_id: opt.object.nodo.id,
              operation: opt.operation || "Spostamento nodo",
              change: change
            }]
          };

          // write into log table queries on archi
          for (var idx=0; idx<opt.object.archi.length; idx++)
          {
            var obj = resT["arco_"+idx].result[0];
            var change = [];

            Object.keys(obj).forEach(function(key)
            {
              if (key == 'lunghezza')
              {
                change.push({
                  key:key,
                  new:opt.object.archi[idx].lunghezza,
                  old:obj[key]
                });
              }

              if (key == 'nodo_da' && opt.object.nodo.id == obj[key])
              {
                change.push({
                  key:key,
                  new: opt.object.overlapNodes[0].id,
                  old:obj[key]
                });
              }

              if (key == 'nodo_a' && opt.object.nodo.id == obj[key])
              {
                change.push({
                  key:key,
                  new:opt.object.overlapNodes[0].id,
                  old:obj[key]
                });
              }
            });

            var arcoLog = {
              user_id: opt.sysuser_id,
              entity: "arco",
              entity_id: obj.cod_arco,
              operation: opt.operation || "Spostamento nodo",
              change: change
            };

            logOpt.object.push(arcoLog);
          }


          self.entityHolder.getEntity("grafoLog").bulkInsert(
            logOpt,
            function(lErr,lRes){}
          );

        });
      }
    });
  });
}

// find valid nodo at given coordinates
nodo.prototype.findNodoAtCoords = function(opt,callback)
{
  if (!opt.object.x && !opt.object.y)
  {
    var msg = "missing coordinates into request!";
    self.log.error(self.moduleName + " - " + msg);
    callback({message:msg}, null)
  }

  /*
   * Query to execute:
   *
   * SELECT id from grafo.nodo
   * WHERE geom = ST_SetSRID(st_makePoint(<x>,<y>),32633)
   * AND (data_fine IS NULL OR data_fine > <now>)
   *
   */

  var qStr =
    "SELECT id from grafo.nodo " +
    "WHERE geom = ST_SetSRID(ST_MakePoint($1,$2),32633) " +
    "AND (data_fine IS NULL OR data_fine > $3)";

  var qVal = [
    {value: opt.object.x},
    {value: opt.object.y},
    {value: new Date().getTime(), type:self.crudUtils.TIMESTAMP},
  ];

  self.crud.select({queryString:qStr},qVal, function(err, res)
  {
    if (err)
    {
      self.log.error(self.moduleName +
        " - Error on find nodo at coords ("+opt.object.x+", "+opt.object.y+"): " + err.message);
    }

    callback(err, res);
  });
}
/*
 * Private function
 */

// build task to update geom and lunghezza for archi linked to given nodo
function createArcoTask(idx, arco, overlap, nodo, tasks, transName, opt)
{
  var arcoGeom =
    "ST_SetSRID(" +
      "ST_MakeLine(ARRAY[";

  for (var jdx=0; jdx<arco.coords.length; jdx++)
  {
    arcoGeom += "ST_MakePoint(" + arco.coords[jdx][0] + ", " +
                                  arco.coords[jdx][1] + ")";

    if (jdx < arco.coords.length -1)
      arcoGeom += ", ";
  }

  arcoGeom += "]), " + self.tableSrid + ")";

  var qString =
    "UPDATE grafo.arco AS NEW SET geom = " + arcoGeom + ", lunghezza = $1";

  var qRet = "RETURNING OLD.lunghezza,";

  var qVal = [
    {value:arco.lunghezza}
  ];

  if (overlap && overlap.length > 0)
  {
    qString +=
      ",nodo_da = CASE WHEN OLD.nodo_da = $2 THEN $3 ELSE OLD.nodo_da END,"  +
      " nodo_a  = CASE WHEN OLD.nodo_a = $2 THEN $3 ELSE OLD.nodo_a END";

    qVal.push({value:nodo.id});
    qVal.push({value:overlap[0].id});

    qRet += "OLD.nodo_da, OLD.nodo_a,";
  }

  // add FROM
  qString += " FROM grafo.arco AS OLD ";

  // add where condition
  qString += " WHERE OLD.cod_arco = $" + (qVal.length+1) + " AND OLD.cod_arco = NEW.cod_arco ";

  qString += qRet + "OLD.cod_arco;";

  qVal.push({value:arco.id});

  var arcoOpt = {
    sysuser_id:opt.sysuser_id,
    transName: transName,
    queryString: qString
  };

  tasks['arco_'+idx] = function(cb){self.crud.update(arcoOpt, qVal, cb);};
}

/*
 * Export
 */
exports.nodo = nodo;
